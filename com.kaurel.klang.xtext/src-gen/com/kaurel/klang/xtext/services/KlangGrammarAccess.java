/*
 * generated by Xtext 2.10.0-SNAPSHOT
 */
package com.kaurel.klang.xtext.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractEnumRuleElementFinder;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class KlangGrammarAccess extends AbstractGrammarElementFinder {
	
	public class GameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Game");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cGameAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cVariablesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVariablesVariableParserRuleCall_1_0 = (RuleCall)cVariablesAssignment_1.eContents().get(0);
		private final Assignment cActorDefsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cActorDefsSpriteParserRuleCall_2_0 = (RuleCall)cActorDefsAssignment_2.eContents().get(0);
		
		//Game:
		//	{Game} variables+=Variable*
		//	actorDefs+=Sprite*;
		@Override public ParserRule getRule() { return rule; }
		
		//{Game} variables+=Variable* actorDefs+=Sprite*
		public Group getGroup() { return cGroup; }
		
		//{Game}
		public Action getGameAction_0() { return cGameAction_0; }
		
		//variables+=Variable*
		public Assignment getVariablesAssignment_1() { return cVariablesAssignment_1; }
		
		//Variable
		public RuleCall getVariablesVariableParserRuleCall_1_0() { return cVariablesVariableParserRuleCall_1_0; }
		
		//actorDefs+=Sprite*
		public Assignment getActorDefsAssignment_2() { return cActorDefsAssignment_2; }
		
		//Sprite
		public RuleCall getActorDefsSpriteParserRuleCall_2_0() { return cActorDefsSpriteParserRuleCall_2_0; }
	}
	public class SpriteElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Sprite");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSpriteAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cSpriteKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final RuleCall cBEGINTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Assignment cVariablesAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cVariablesVariableParserRuleCall_4_0 = (RuleCall)cVariablesAssignment_4.eContents().get(0);
		private final Assignment cEventHandlersAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cEventHandlersEventHandlerParserRuleCall_5_0 = (RuleCall)cEventHandlersAssignment_5.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_6 = (RuleCall)cGroup.eContents().get(6);
		
		//Sprite:
		//	{Sprite}
		//	'sprite'
		//	name=ID
		//	BEGIN
		//	variables+=Variable*
		//	eventHandlers+=EventHandler*
		//	END;
		@Override public ParserRule getRule() { return rule; }
		
		//{Sprite} 'sprite' name=ID BEGIN variables+=Variable* eventHandlers+=EventHandler* END
		public Group getGroup() { return cGroup; }
		
		//{Sprite}
		public Action getSpriteAction_0() { return cSpriteAction_0; }
		
		//'sprite'
		public Keyword getSpriteKeyword_1() { return cSpriteKeyword_1; }
		
		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_3() { return cBEGINTerminalRuleCall_3; }
		
		//variables+=Variable*
		public Assignment getVariablesAssignment_4() { return cVariablesAssignment_4; }
		
		//Variable
		public RuleCall getVariablesVariableParserRuleCall_4_0() { return cVariablesVariableParserRuleCall_4_0; }
		
		//eventHandlers+=EventHandler*
		public Assignment getEventHandlersAssignment_5() { return cEventHandlersAssignment_5; }
		
		//EventHandler
		public RuleCall getEventHandlersEventHandlerParserRuleCall_5_0() { return cEventHandlersEventHandlerParserRuleCall_5_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_6() { return cENDTerminalRuleCall_6; }
	}
	public class EventHandlerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.EventHandler");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhenKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cEventTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cEventTypeEventTypeEnumRuleCall_1_0 = (RuleCall)cEventTypeAssignment_1.eContents().get(0);
		private final RuleCall cBEGINTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cStatementsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cStatementsStatementParserRuleCall_3_0 = (RuleCall)cStatementsAssignment_3.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		//EventHandler:
		//	'when'
		//	eventType=EventType
		//	BEGIN
		//	statements+=Statement*
		//	END;
		@Override public ParserRule getRule() { return rule; }
		
		//'when' eventType=EventType BEGIN statements+=Statement* END
		public Group getGroup() { return cGroup; }
		
		//'when'
		public Keyword getWhenKeyword_0() { return cWhenKeyword_0; }
		
		//eventType=EventType
		public Assignment getEventTypeAssignment_1() { return cEventTypeAssignment_1; }
		
		//EventType
		public RuleCall getEventTypeEventTypeEnumRuleCall_1_0() { return cEventTypeEventTypeEnumRuleCall_1_0; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_2() { return cBEGINTerminalRuleCall_2; }
		
		//statements+=Statement*
		public Assignment getStatementsAssignment_3() { return cStatementsAssignment_3; }
		
		//Statement
		public RuleCall getStatementsStatementParserRuleCall_3_0() { return cStatementsStatementParserRuleCall_3_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_4() { return cENDTerminalRuleCall_4; }
	}
	public class WhileLoopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.WhileLoop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cWhileLoopAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cWhileKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cPredicateAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPredicateExpressionParserRuleCall_2_0 = (RuleCall)cPredicateAssignment_2.eContents().get(0);
		private final RuleCall cBEGINTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Assignment cLoopBlockAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cLoopBlockStatementParserRuleCall_4_0 = (RuleCall)cLoopBlockAssignment_4.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		
		//WhileLoop:
		//	{WhileLoop}
		//	'while' predicate=Expression
		//	BEGIN
		//	loopBlock+=Statement*
		//	END;
		@Override public ParserRule getRule() { return rule; }
		
		//{WhileLoop} 'while' predicate=Expression BEGIN loopBlock+=Statement* END
		public Group getGroup() { return cGroup; }
		
		//{WhileLoop}
		public Action getWhileLoopAction_0() { return cWhileLoopAction_0; }
		
		//'while'
		public Keyword getWhileKeyword_1() { return cWhileKeyword_1; }
		
		//predicate=Expression
		public Assignment getPredicateAssignment_2() { return cPredicateAssignment_2; }
		
		//Expression
		public RuleCall getPredicateExpressionParserRuleCall_2_0() { return cPredicateExpressionParserRuleCall_2_0; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_3() { return cBEGINTerminalRuleCall_3; }
		
		//loopBlock+=Statement*
		public Assignment getLoopBlockAssignment_4() { return cLoopBlockAssignment_4; }
		
		//Statement
		public RuleCall getLoopBlockStatementParserRuleCall_4_0() { return cLoopBlockStatementParserRuleCall_4_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_5() { return cENDTerminalRuleCall_5; }
	}
	public class IfElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.If");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cIfAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cIfKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cPredicateAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPredicateExpressionParserRuleCall_2_0 = (RuleCall)cPredicateAssignment_2.eContents().get(0);
		private final RuleCall cBEGINTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Assignment cIfBlockAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cIfBlockStatementParserRuleCall_4_0 = (RuleCall)cIfBlockAssignment_4.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		
		//If:
		//	{If}
		//	'if' predicate=Expression
		//	BEGIN
		//	ifBlock+=Statement*
		//	END;
		@Override public ParserRule getRule() { return rule; }
		
		//{If} 'if' predicate=Expression BEGIN ifBlock+=Statement* END
		public Group getGroup() { return cGroup; }
		
		//{If}
		public Action getIfAction_0() { return cIfAction_0; }
		
		//'if'
		public Keyword getIfKeyword_1() { return cIfKeyword_1; }
		
		//predicate=Expression
		public Assignment getPredicateAssignment_2() { return cPredicateAssignment_2; }
		
		//Expression
		public RuleCall getPredicateExpressionParserRuleCall_2_0() { return cPredicateExpressionParserRuleCall_2_0; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_3() { return cBEGINTerminalRuleCall_3; }
		
		//ifBlock+=Statement*
		public Assignment getIfBlockAssignment_4() { return cIfBlockAssignment_4; }
		
		//Statement
		public RuleCall getIfBlockStatementParserRuleCall_4_0() { return cIfBlockStatementParserRuleCall_4_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_5() { return cENDTerminalRuleCall_5; }
	}
	public class ForeverLoopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.ForeverLoop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cForeverLoopAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cForeverKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cBEGINTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cLoopStatementsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cLoopStatementsStatementParserRuleCall_3_0 = (RuleCall)cLoopStatementsAssignment_3.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		//ForeverLoop:
		//	{ForeverLoop}
		//	'forever'
		//	BEGIN
		//	loopStatements+=Statement*
		//	END;
		@Override public ParserRule getRule() { return rule; }
		
		//{ForeverLoop} 'forever' BEGIN loopStatements+=Statement* END
		public Group getGroup() { return cGroup; }
		
		//{ForeverLoop}
		public Action getForeverLoopAction_0() { return cForeverLoopAction_0; }
		
		//'forever'
		public Keyword getForeverKeyword_1() { return cForeverKeyword_1; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_2() { return cBEGINTerminalRuleCall_2; }
		
		//loopStatements+=Statement*
		public Assignment getLoopStatementsAssignment_3() { return cLoopStatementsAssignment_3; }
		
		//Statement
		public RuleCall getLoopStatementsStatementParserRuleCall_3_0() { return cLoopStatementsStatementParserRuleCall_3_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_4() { return cENDTerminalRuleCall_4; }
	}
	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cControlStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cVariableParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cAssignmentParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cSubroutineCallParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//Statement:
		//	ControlStatement | Variable | Assignment | SubroutineCall;
		@Override public ParserRule getRule() { return rule; }
		
		//ControlStatement | Variable | Assignment | SubroutineCall
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ControlStatement
		public RuleCall getControlStatementParserRuleCall_0() { return cControlStatementParserRuleCall_0; }
		
		//Variable
		public RuleCall getVariableParserRuleCall_1() { return cVariableParserRuleCall_1; }
		
		//Assignment
		public RuleCall getAssignmentParserRuleCall_2() { return cAssignmentParserRuleCall_2; }
		
		//SubroutineCall
		public RuleCall getSubroutineCallParserRuleCall_3() { return cSubroutineCallParserRuleCall_3; }
	}
	public class SubroutineCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.SubroutineCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cParametersAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cParametersExpressionParserRuleCall_2_0 = (RuleCall)cParametersAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cParametersAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cParametersExpressionParserRuleCall_3_1_0 = (RuleCall)cParametersAssignment_3_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//SubroutineCall:
		//	name=ID '(' parameters+=Expression? (',' parameters+=Expression)* ')';
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID '(' parameters+=Expression? (',' parameters+=Expression)* ')'
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//parameters+=Expression?
		public Assignment getParametersAssignment_2() { return cParametersAssignment_2; }
		
		//Expression
		public RuleCall getParametersExpressionParserRuleCall_2_0() { return cParametersExpressionParserRuleCall_2_0; }
		
		//(',' parameters+=Expression)*
		public Group getGroup_3() { return cGroup_3; }
		
		//','
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }
		
		//parameters+=Expression
		public Assignment getParametersAssignment_3_1() { return cParametersAssignment_3_1; }
		
		//Expression
		public RuleCall getParametersExpressionParserRuleCall_3_1_0() { return cParametersExpressionParserRuleCall_3_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class ControlStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.ControlStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cForeverLoopParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cWhileLoopParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cYieldParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cIfParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//ControlStatement:
		//	ForeverLoop | WhileLoop | Yield | If;
		@Override public ParserRule getRule() { return rule; }
		
		//ForeverLoop | WhileLoop | Yield | If
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ForeverLoop
		public RuleCall getForeverLoopParserRuleCall_0() { return cForeverLoopParserRuleCall_0; }
		
		//WhileLoop
		public RuleCall getWhileLoopParserRuleCall_1() { return cWhileLoopParserRuleCall_1; }
		
		//Yield
		public RuleCall getYieldParserRuleCall_2() { return cYieldParserRuleCall_2; }
		
		//If
		public RuleCall getIfParserRuleCall_3() { return cIfParserRuleCall_3; }
	}
	public class YieldElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Yield");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cYieldAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cYieldKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//Yield:
		//	{Yield}
		//	'yield';
		@Override public ParserRule getRule() { return rule; }
		
		//{Yield} 'yield'
		public Group getGroup() { return cGroup; }
		
		//{Yield}
		public Action getYieldAction_0() { return cYieldAction_0; }
		
		//'yield'
		public Keyword getYieldKeyword_1() { return cYieldKeyword_1; }
	}
	public class VariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Variable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cVarKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cExpressionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cExpressionExpressionParserRuleCall_3_0 = (RuleCall)cExpressionAssignment_3.eContents().get(0);
		
		//Variable:
		//	'var' name=ID '=' expression=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//'var' name=ID '=' expression=Expression
		public Group getGroup() { return cGroup; }
		
		//'var'
		public Keyword getVarKeyword_0() { return cVarKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_3() { return cExpressionAssignment_3; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_3_0() { return cExpressionExpressionParserRuleCall_3_0; }
	}
	public class AssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Assignment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVariableAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cVariableVariableCrossReference_0_0 = (CrossReference)cVariableAssignment_0.eContents().get(0);
		private final RuleCall cVariableVariableIDTerminalRuleCall_0_0_1 = (RuleCall)cVariableVariableCrossReference_0_0.eContents().get(1);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionExpressionParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		
		//Assignment:
		//	variable=[Variable] '=' expression=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//variable=[Variable] '=' expression=Expression
		public Group getGroup() { return cGroup; }
		
		//variable=[Variable]
		public Assignment getVariableAssignment_0() { return cVariableAssignment_0; }
		
		//[Variable]
		public CrossReference getVariableVariableCrossReference_0_0() { return cVariableVariableCrossReference_0_0; }
		
		//ID
		public RuleCall getVariableVariableIDTerminalRuleCall_0_0_1() { return cVariableVariableIDTerminalRuleCall_0_0_1; }
		
		//'='
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_0() { return cExpressionExpressionParserRuleCall_2_0; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Expression");
		private final RuleCall cOrParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Expression:
		//	Or;
		@Override public ParserRule getRule() { return rule; }
		
		//Or
		public RuleCall getOrParserRuleCall() { return cOrParserRuleCall; }
	}
	public class OrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Or");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cOrKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAndParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Or Expression:
		//	And ({Or.left=current} 'or' right=And)*
		@Override public ParserRule getRule() { return rule; }
		
		//And ({Or.left=current} 'or' right=And)*
		public Group getGroup() { return cGroup; }
		
		//And
		public RuleCall getAndParserRuleCall_0() { return cAndParserRuleCall_0; }
		
		//({Or.left=current} 'or' right=And)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Or.left=current}
		public Action getOrLeftAction_1_0() { return cOrLeftAction_1_0; }
		
		//'or'
		public Keyword getOrKeyword_1_1() { return cOrKeyword_1_1; }
		
		//right=And
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//And
		public RuleCall getRightAndParserRuleCall_1_2_0() { return cRightAndParserRuleCall_1_2_0; }
	}
	public class AndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.And");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cComparisonParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAndKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightComparisonParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//And Expression:
		//	Comparison ({And.left=current} 'and' right=Comparison)*
		@Override public ParserRule getRule() { return rule; }
		
		//Comparison ({And.left=current} 'and' right=Comparison)*
		public Group getGroup() { return cGroup; }
		
		//Comparison
		public RuleCall getComparisonParserRuleCall_0() { return cComparisonParserRuleCall_0; }
		
		//({And.left=current} 'and' right=Comparison)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{And.left=current}
		public Action getAndLeftAction_1_0() { return cAndLeftAction_1_0; }
		
		//'and'
		public Keyword getAndKeyword_1_1() { return cAndKeyword_1_1; }
		
		//right=Comparison
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Comparison
		public RuleCall getRightComparisonParserRuleCall_1_2_0() { return cRightComparisonParserRuleCall_1_2_0; }
	}
	public class PlusElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Plus");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMinusParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cPlusLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightMinusParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Plus Expression:
		//	Minus ({Plus.left=current} '+' right=Minus)*
		@Override public ParserRule getRule() { return rule; }
		
		//Minus ({Plus.left=current} '+' right=Minus)*
		public Group getGroup() { return cGroup; }
		
		//Minus
		public RuleCall getMinusParserRuleCall_0() { return cMinusParserRuleCall_0; }
		
		//({Plus.left=current} '+' right=Minus)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Plus.left=current}
		public Action getPlusLeftAction_1_0() { return cPlusLeftAction_1_0; }
		
		//'+'
		public Keyword getPlusSignKeyword_1_1() { return cPlusSignKeyword_1_1; }
		
		//right=Minus
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Minus
		public RuleCall getRightMinusParserRuleCall_1_2_0() { return cRightMinusParserRuleCall_1_2_0; }
	}
	public class MinusElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Minus");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplyParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMinusLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightMultiplyParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Minus Expression:
		//	Multiply ({Minus.left=current} '-' right=Multiply)*
		@Override public ParserRule getRule() { return rule; }
		
		//Multiply ({Minus.left=current} '-' right=Multiply)*
		public Group getGroup() { return cGroup; }
		
		//Multiply
		public RuleCall getMultiplyParserRuleCall_0() { return cMultiplyParserRuleCall_0; }
		
		//({Minus.left=current} '-' right=Multiply)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Minus.left=current}
		public Action getMinusLeftAction_1_0() { return cMinusLeftAction_1_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_1_1() { return cHyphenMinusKeyword_1_1; }
		
		//right=Multiply
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Multiply
		public RuleCall getRightMultiplyParserRuleCall_1_2_0() { return cRightMultiplyParserRuleCall_1_2_0; }
	}
	public class MultiplyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Multiply");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cDivideParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMultiplyLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAsteriskKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightDivideParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Multiply Expression:
		//	Divide ({Multiply.left=current} '*' right=Divide)*
		@Override public ParserRule getRule() { return rule; }
		
		//Divide ({Multiply.left=current} '*' right=Divide)*
		public Group getGroup() { return cGroup; }
		
		//Divide
		public RuleCall getDivideParserRuleCall_0() { return cDivideParserRuleCall_0; }
		
		//({Multiply.left=current} '*' right=Divide)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Multiply.left=current}
		public Action getMultiplyLeftAction_1_0() { return cMultiplyLeftAction_1_0; }
		
		//'*'
		public Keyword getAsteriskKeyword_1_1() { return cAsteriskKeyword_1_1; }
		
		//right=Divide
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Divide
		public RuleCall getRightDivideParserRuleCall_1_2_0() { return cRightDivideParserRuleCall_1_2_0; }
	}
	public class DivideElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Divide");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cDivideLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cSolidusKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPrimaryExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Divide Expression:
		//	PrimaryExpression ({Divide.left=current} '/' right=PrimaryExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//PrimaryExpression ({Divide.left=current} '/' right=PrimaryExpression)*
		public Group getGroup() { return cGroup; }
		
		//PrimaryExpression
		public RuleCall getPrimaryExpressionParserRuleCall_0() { return cPrimaryExpressionParserRuleCall_0; }
		
		//({Divide.left=current} '/' right=PrimaryExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Divide.left=current}
		public Action getDivideLeftAction_1_0() { return cDivideLeftAction_1_0; }
		
		//'/'
		public Keyword getSolidusKeyword_1_1() { return cSolidusKeyword_1_1; }
		
		//right=PrimaryExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//PrimaryExpression
		public RuleCall getRightPrimaryExpressionParserRuleCall_1_2_0() { return cRightPrimaryExpressionParserRuleCall_1_2_0; }
	}
	public class ComparisonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Comparison");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPlusParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Keyword cLessThanSignKeyword_1_0_0_0 = (Keyword)cGroup_1_0_0.eContents().get(0);
		private final Action cLessThanLeftAction_1_0_0_1 = (Action)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Keyword cEqualsSignKeyword_1_0_1_0 = (Keyword)cGroup_1_0_1.eContents().get(0);
		private final Action cEqualLeftAction_1_0_1_1 = (Action)cGroup_1_0_1.eContents().get(1);
		private final Group cGroup_1_0_2 = (Group)cAlternatives_1_0.eContents().get(2);
		private final Keyword cGreaterThanSignKeyword_1_0_2_0 = (Keyword)cGroup_1_0_2.eContents().get(0);
		private final Action cGreaterThanLeftAction_1_0_2_1 = (Action)cGroup_1_0_2.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightPlusParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//Comparison Expression:
		//	Plus (('<' {LessThan.left=current} | '=' {Equal.left=current} | '>' {GreaterThan.left=current}) right=Plus)*
		@Override public ParserRule getRule() { return rule; }
		
		//Plus (('<' {LessThan.left=current} | '=' {Equal.left=current} | '>' {GreaterThan.left=current}) right=Plus)*
		public Group getGroup() { return cGroup; }
		
		//Plus
		public RuleCall getPlusParserRuleCall_0() { return cPlusParserRuleCall_0; }
		
		//(('<' {LessThan.left=current} | '=' {Equal.left=current} | '>' {GreaterThan.left=current}) right=Plus)*
		public Group getGroup_1() { return cGroup_1; }
		
		//('<' {LessThan.left=current} | '=' {Equal.left=current} | '>' {GreaterThan.left=current})
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }
		
		//'<' {LessThan.left=current}
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//'<'
		public Keyword getLessThanSignKeyword_1_0_0_0() { return cLessThanSignKeyword_1_0_0_0; }
		
		//{LessThan.left=current}
		public Action getLessThanLeftAction_1_0_0_1() { return cLessThanLeftAction_1_0_0_1; }
		
		//'=' {Equal.left=current}
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }
		
		//'='
		public Keyword getEqualsSignKeyword_1_0_1_0() { return cEqualsSignKeyword_1_0_1_0; }
		
		//{Equal.left=current}
		public Action getEqualLeftAction_1_0_1_1() { return cEqualLeftAction_1_0_1_1; }
		
		//'>' {GreaterThan.left=current}
		public Group getGroup_1_0_2() { return cGroup_1_0_2; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword_1_0_2_0() { return cGreaterThanSignKeyword_1_0_2_0; }
		
		//{GreaterThan.left=current}
		public Action getGreaterThanLeftAction_1_0_2_1() { return cGreaterThanLeftAction_1_0_2_1; }
		
		//right=Plus
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//Plus
		public RuleCall getRightPlusParserRuleCall_1_1_0() { return cRightPlusParserRuleCall_1_1_0; }
	}
	public class PrimaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.PrimaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cNotAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final RuleCall cNotOpParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Assignment cExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cExpressionPrimaryExpressionParserRuleCall_1_2_0 = (RuleCall)cExpressionAssignment_1_2.eContents().get(0);
		private final RuleCall cAtomicExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//PrimaryExpression Expression:
		//	'(' Expression ')' | {Not} NotOp expression=PrimaryExpression | AtomicExpression
		@Override public ParserRule getRule() { return rule; }
		
		//'(' Expression ')' | {Not} NotOp expression=PrimaryExpression | AtomicExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'(' Expression ')'
		public Group getGroup_0() { return cGroup_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_0_1() { return cExpressionParserRuleCall_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }
		
		//{Not} NotOp expression=PrimaryExpression
		public Group getGroup_1() { return cGroup_1; }
		
		//{Not}
		public Action getNotAction_1_0() { return cNotAction_1_0; }
		
		//NotOp
		public RuleCall getNotOpParserRuleCall_1_1() { return cNotOpParserRuleCall_1_1; }
		
		//expression=PrimaryExpression
		public Assignment getExpressionAssignment_1_2() { return cExpressionAssignment_1_2; }
		
		//PrimaryExpression
		public RuleCall getExpressionPrimaryExpressionParserRuleCall_1_2_0() { return cExpressionPrimaryExpressionParserRuleCall_1_2_0; }
		
		//AtomicExpression
		public RuleCall getAtomicExpressionParserRuleCall_2() { return cAtomicExpressionParserRuleCall_2; }
	}
	public class NotOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.NotOp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cExclamationMarkKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cNotKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//NotOp:
		//	'!' | 'not';
		@Override public ParserRule getRule() { return rule; }
		
		//'!' | 'not'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'!'
		public Keyword getExclamationMarkKeyword_0() { return cExclamationMarkKeyword_0; }
		
		//'not'
		public Keyword getNotKeyword_1() { return cNotKeyword_1; }
	}
	public class AtomicExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.AtomicExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cBooleanLiteralAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Alternatives cAlternatives_0_1 = (Alternatives)cGroup_0.eContents().get(1);
		private final Assignment cValueAssignment_0_1_0 = (Assignment)cAlternatives_0_1.eContents().get(0);
		private final Keyword cValueTrueKeyword_0_1_0_0 = (Keyword)cValueAssignment_0_1_0.eContents().get(0);
		private final Keyword cFalseKeyword_0_1_1 = (Keyword)cAlternatives_0_1.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cNumericLiteralAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValueNUMERICTerminalRuleCall_1_1_0 = (RuleCall)cValueAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cStringLiteralAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Assignment cValueAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_2_1_0 = (RuleCall)cValueAssignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cVariableRefAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final Assignment cVariableNameAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cVariableNameIDTerminalRuleCall_3_1_0 = (RuleCall)cVariableNameAssignment_3_1.eContents().get(0);
		
		//AtomicExpression Expression:
		//	{BooleanLiteral} (value?='true' | 'false') | {NumericLiteral} value=NUMERIC | {StringLiteral} value=STRING |
		//	{VariableRef} variableName=ID
		@Override public ParserRule getRule() { return rule; }
		
		//{BooleanLiteral} (value?='true' | 'false') | {NumericLiteral} value=NUMERIC | {StringLiteral} value=STRING |
		//{VariableRef} variableName=ID
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{BooleanLiteral} (value?='true' | 'false')
		public Group getGroup_0() { return cGroup_0; }
		
		//{BooleanLiteral}
		public Action getBooleanLiteralAction_0_0() { return cBooleanLiteralAction_0_0; }
		
		//(value?='true' | 'false')
		public Alternatives getAlternatives_0_1() { return cAlternatives_0_1; }
		
		//value?='true'
		public Assignment getValueAssignment_0_1_0() { return cValueAssignment_0_1_0; }
		
		//'true'
		public Keyword getValueTrueKeyword_0_1_0_0() { return cValueTrueKeyword_0_1_0_0; }
		
		//'false'
		public Keyword getFalseKeyword_0_1_1() { return cFalseKeyword_0_1_1; }
		
		//{NumericLiteral} value=NUMERIC
		public Group getGroup_1() { return cGroup_1; }
		
		//{NumericLiteral}
		public Action getNumericLiteralAction_1_0() { return cNumericLiteralAction_1_0; }
		
		//value=NUMERIC
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }
		
		//NUMERIC
		public RuleCall getValueNUMERICTerminalRuleCall_1_1_0() { return cValueNUMERICTerminalRuleCall_1_1_0; }
		
		//{StringLiteral} value=STRING
		public Group getGroup_2() { return cGroup_2; }
		
		//{StringLiteral}
		public Action getStringLiteralAction_2_0() { return cStringLiteralAction_2_0; }
		
		//value=STRING
		public Assignment getValueAssignment_2_1() { return cValueAssignment_2_1; }
		
		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_2_1_0() { return cValueSTRINGTerminalRuleCall_2_1_0; }
		
		//{VariableRef} variableName=ID
		public Group getGroup_3() { return cGroup_3; }
		
		//{VariableRef}
		public Action getVariableRefAction_3_0() { return cVariableRefAction_3_0; }
		
		//variableName=ID
		public Assignment getVariableNameAssignment_3_1() { return cVariableNameAssignment_3_1; }
		
		//ID
		public RuleCall getVariableNameIDTerminalRuleCall_3_1_0() { return cVariableNameIDTerminalRuleCall_3_1_0; }
	}
	
	public class EventTypeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.EventType");
		private final EnumLiteralDeclaration cGAME_STARTEDEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cGAME_STARTEDGAME_STARTEDKeyword_0 = (Keyword)cGAME_STARTEDEnumLiteralDeclaration.eContents().get(0);
		
		//enum EventType:
		//	GAME_STARTED;
		public EnumRule getRule() { return rule; }
		
		//GAME_STARTED
		public EnumLiteralDeclaration getGAME_STARTEDEnumLiteralDeclaration() { return cGAME_STARTEDEnumLiteralDeclaration; }
		
		//"GAME_STARTED"
		public Keyword getGAME_STARTEDGAME_STARTEDKeyword_0() { return cGAME_STARTEDGAME_STARTEDKeyword_0; }
	}
	
	private final GameElements pGame;
	private final SpriteElements pSprite;
	private final EventHandlerElements pEventHandler;
	private final EventTypeElements eEventType;
	private final WhileLoopElements pWhileLoop;
	private final IfElements pIf;
	private final ForeverLoopElements pForeverLoop;
	private final StatementElements pStatement;
	private final SubroutineCallElements pSubroutineCall;
	private final ControlStatementElements pControlStatement;
	private final YieldElements pYield;
	private final VariableElements pVariable;
	private final AssignmentElements pAssignment;
	private final ExpressionElements pExpression;
	private final OrElements pOr;
	private final AndElements pAnd;
	private final PlusElements pPlus;
	private final MinusElements pMinus;
	private final MultiplyElements pMultiply;
	private final DivideElements pDivide;
	private final ComparisonElements pComparison;
	private final PrimaryExpressionElements pPrimaryExpression;
	private final NotOpElements pNotOp;
	private final AtomicExpressionElements pAtomicExpression;
	private final TerminalRule tBEGIN;
	private final TerminalRule tEND;
	private final TerminalRule tNUMERIC;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public KlangGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pGame = new GameElements();
		this.pSprite = new SpriteElements();
		this.pEventHandler = new EventHandlerElements();
		this.eEventType = new EventTypeElements();
		this.pWhileLoop = new WhileLoopElements();
		this.pIf = new IfElements();
		this.pForeverLoop = new ForeverLoopElements();
		this.pStatement = new StatementElements();
		this.pSubroutineCall = new SubroutineCallElements();
		this.pControlStatement = new ControlStatementElements();
		this.pYield = new YieldElements();
		this.pVariable = new VariableElements();
		this.pAssignment = new AssignmentElements();
		this.pExpression = new ExpressionElements();
		this.pOr = new OrElements();
		this.pAnd = new AndElements();
		this.pPlus = new PlusElements();
		this.pMinus = new MinusElements();
		this.pMultiply = new MultiplyElements();
		this.pDivide = new DivideElements();
		this.pComparison = new ComparisonElements();
		this.pPrimaryExpression = new PrimaryExpressionElements();
		this.pNotOp = new NotOpElements();
		this.pAtomicExpression = new AtomicExpressionElements();
		this.tBEGIN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.BEGIN");
		this.tEND = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.END");
		this.tNUMERIC = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.NUMERIC");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("com.kaurel.klang.xtext.Klang".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Game:
	//	{Game} variables+=Variable*
	//	actorDefs+=Sprite*;
	public GameElements getGameAccess() {
		return pGame;
	}
	
	public ParserRule getGameRule() {
		return getGameAccess().getRule();
	}
	
	//Sprite:
	//	{Sprite}
	//	'sprite'
	//	name=ID
	//	BEGIN
	//	variables+=Variable*
	//	eventHandlers+=EventHandler*
	//	END;
	public SpriteElements getSpriteAccess() {
		return pSprite;
	}
	
	public ParserRule getSpriteRule() {
		return getSpriteAccess().getRule();
	}
	
	//EventHandler:
	//	'when'
	//	eventType=EventType
	//	BEGIN
	//	statements+=Statement*
	//	END;
	public EventHandlerElements getEventHandlerAccess() {
		return pEventHandler;
	}
	
	public ParserRule getEventHandlerRule() {
		return getEventHandlerAccess().getRule();
	}
	
	//enum EventType:
	//	GAME_STARTED;
	public EventTypeElements getEventTypeAccess() {
		return eEventType;
	}
	
	public EnumRule getEventTypeRule() {
		return getEventTypeAccess().getRule();
	}
	
	//WhileLoop:
	//	{WhileLoop}
	//	'while' predicate=Expression
	//	BEGIN
	//	loopBlock+=Statement*
	//	END;
	public WhileLoopElements getWhileLoopAccess() {
		return pWhileLoop;
	}
	
	public ParserRule getWhileLoopRule() {
		return getWhileLoopAccess().getRule();
	}
	
	//If:
	//	{If}
	//	'if' predicate=Expression
	//	BEGIN
	//	ifBlock+=Statement*
	//	END;
	public IfElements getIfAccess() {
		return pIf;
	}
	
	public ParserRule getIfRule() {
		return getIfAccess().getRule();
	}
	
	//ForeverLoop:
	//	{ForeverLoop}
	//	'forever'
	//	BEGIN
	//	loopStatements+=Statement*
	//	END;
	public ForeverLoopElements getForeverLoopAccess() {
		return pForeverLoop;
	}
	
	public ParserRule getForeverLoopRule() {
		return getForeverLoopAccess().getRule();
	}
	
	//Statement:
	//	ControlStatement | Variable | Assignment | SubroutineCall;
	public StatementElements getStatementAccess() {
		return pStatement;
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}
	
	//SubroutineCall:
	//	name=ID '(' parameters+=Expression? (',' parameters+=Expression)* ')';
	public SubroutineCallElements getSubroutineCallAccess() {
		return pSubroutineCall;
	}
	
	public ParserRule getSubroutineCallRule() {
		return getSubroutineCallAccess().getRule();
	}
	
	//ControlStatement:
	//	ForeverLoop | WhileLoop | Yield | If;
	public ControlStatementElements getControlStatementAccess() {
		return pControlStatement;
	}
	
	public ParserRule getControlStatementRule() {
		return getControlStatementAccess().getRule();
	}
	
	//Yield:
	//	{Yield}
	//	'yield';
	public YieldElements getYieldAccess() {
		return pYield;
	}
	
	public ParserRule getYieldRule() {
		return getYieldAccess().getRule();
	}
	
	//Variable:
	//	'var' name=ID '=' expression=Expression;
	public VariableElements getVariableAccess() {
		return pVariable;
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}
	
	//Assignment:
	//	variable=[Variable] '=' expression=Expression;
	public AssignmentElements getAssignmentAccess() {
		return pAssignment;
	}
	
	public ParserRule getAssignmentRule() {
		return getAssignmentAccess().getRule();
	}
	
	//Expression:
	//	Or;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//Or Expression:
	//	And ({Or.left=current} 'or' right=And)*
	public OrElements getOrAccess() {
		return pOr;
	}
	
	public ParserRule getOrRule() {
		return getOrAccess().getRule();
	}
	
	//And Expression:
	//	Comparison ({And.left=current} 'and' right=Comparison)*
	public AndElements getAndAccess() {
		return pAnd;
	}
	
	public ParserRule getAndRule() {
		return getAndAccess().getRule();
	}
	
	//Plus Expression:
	//	Minus ({Plus.left=current} '+' right=Minus)*
	public PlusElements getPlusAccess() {
		return pPlus;
	}
	
	public ParserRule getPlusRule() {
		return getPlusAccess().getRule();
	}
	
	//Minus Expression:
	//	Multiply ({Minus.left=current} '-' right=Multiply)*
	public MinusElements getMinusAccess() {
		return pMinus;
	}
	
	public ParserRule getMinusRule() {
		return getMinusAccess().getRule();
	}
	
	//Multiply Expression:
	//	Divide ({Multiply.left=current} '*' right=Divide)*
	public MultiplyElements getMultiplyAccess() {
		return pMultiply;
	}
	
	public ParserRule getMultiplyRule() {
		return getMultiplyAccess().getRule();
	}
	
	//Divide Expression:
	//	PrimaryExpression ({Divide.left=current} '/' right=PrimaryExpression)*
	public DivideElements getDivideAccess() {
		return pDivide;
	}
	
	public ParserRule getDivideRule() {
		return getDivideAccess().getRule();
	}
	
	//Comparison Expression:
	//	Plus (('<' {LessThan.left=current} | '=' {Equal.left=current} | '>' {GreaterThan.left=current}) right=Plus)*
	public ComparisonElements getComparisonAccess() {
		return pComparison;
	}
	
	public ParserRule getComparisonRule() {
		return getComparisonAccess().getRule();
	}
	
	//PrimaryExpression Expression:
	//	'(' Expression ')' | {Not} NotOp expression=PrimaryExpression | AtomicExpression
	public PrimaryExpressionElements getPrimaryExpressionAccess() {
		return pPrimaryExpression;
	}
	
	public ParserRule getPrimaryExpressionRule() {
		return getPrimaryExpressionAccess().getRule();
	}
	
	//NotOp:
	//	'!' | 'not';
	public NotOpElements getNotOpAccess() {
		return pNotOp;
	}
	
	public ParserRule getNotOpRule() {
		return getNotOpAccess().getRule();
	}
	
	//AtomicExpression Expression:
	//	{BooleanLiteral} (value?='true' | 'false') | {NumericLiteral} value=NUMERIC | {StringLiteral} value=STRING |
	//	{VariableRef} variableName=ID
	public AtomicExpressionElements getAtomicExpressionAccess() {
		return pAtomicExpression;
	}
	
	public ParserRule getAtomicExpressionRule() {
		return getAtomicExpressionAccess().getRule();
	}
	
	//terminal BEGIN:
	//	'synthetic:BEGIN';
	public TerminalRule getBEGINRule() {
		return tBEGIN;
	}
	
	//terminal END:
	//	'synthetic:END';
	public TerminalRule getENDRule() {
		return tEND;
	}
	
	//terminal NUMERIC returns ecore::EDouble:
	//	'0'..'9'+;
	public TerminalRule getNUMERICRule() {
		return tNUMERIC;
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/ *'->'* /';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
