/*
 * generated by Xtext 2.10.0-SNAPSHOT
 */
package com.kaurel.klang.xtext.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class KlangGrammarAccess extends AbstractGrammarElementFinder {
	
	public class GameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Game");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cGameAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cVariableDeclarationsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVariableDeclarationsVariableParserRuleCall_1_0 = (RuleCall)cVariableDeclarationsAssignment_1.eContents().get(0);
		private final Assignment cActorDefsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cActorDefsActorParserRuleCall_2_0 = (RuleCall)cActorDefsAssignment_2.eContents().get(0);
		
		//Game:
		//	{Game} variableDeclarations+=Variable*
		//	actorDefs+=Actor*;
		@Override public ParserRule getRule() { return rule; }
		
		//{Game} variableDeclarations+=Variable* actorDefs+=Actor*
		public Group getGroup() { return cGroup; }
		
		//{Game}
		public Action getGameAction_0() { return cGameAction_0; }
		
		//variableDeclarations+=Variable*
		public Assignment getVariableDeclarationsAssignment_1() { return cVariableDeclarationsAssignment_1; }
		
		//Variable
		public RuleCall getVariableDeclarationsVariableParserRuleCall_1_0() { return cVariableDeclarationsVariableParserRuleCall_1_0; }
		
		//actorDefs+=Actor*
		public Assignment getActorDefsAssignment_2() { return cActorDefsAssignment_2; }
		
		//Actor
		public RuleCall getActorDefsActorParserRuleCall_2_0() { return cActorDefsActorParserRuleCall_2_0; }
	}
	public class ActorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Actor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cActorAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cEntityAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cEntityEntityParserRuleCall_1_0 = (RuleCall)cEntityAssignment_1.eContents().get(0);
		private final RuleCall cBEGINTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cVariableDeclarationsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cVariableDeclarationsVariableParserRuleCall_3_0 = (RuleCall)cVariableDeclarationsAssignment_3.eContents().get(0);
		private final Assignment cEventHandlersAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cEventHandlersEventHandlerParserRuleCall_4_0 = (RuleCall)cEventHandlersAssignment_4.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		
		//Actor:
		//	{Actor} entity=Entity
		//	BEGIN
		//	variableDeclarations+=Variable*
		//	eventHandlers+=EventHandler*
		//	END;
		@Override public ParserRule getRule() { return rule; }
		
		//{Actor} entity=Entity BEGIN variableDeclarations+=Variable* eventHandlers+=EventHandler* END
		public Group getGroup() { return cGroup; }
		
		//{Actor}
		public Action getActorAction_0() { return cActorAction_0; }
		
		//entity=Entity
		public Assignment getEntityAssignment_1() { return cEntityAssignment_1; }
		
		//Entity
		public RuleCall getEntityEntityParserRuleCall_1_0() { return cEntityEntityParserRuleCall_1_0; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_2() { return cBEGINTerminalRuleCall_2; }
		
		//variableDeclarations+=Variable*
		public Assignment getVariableDeclarationsAssignment_3() { return cVariableDeclarationsAssignment_3; }
		
		//Variable
		public RuleCall getVariableDeclarationsVariableParserRuleCall_3_0() { return cVariableDeclarationsVariableParserRuleCall_3_0; }
		
		//eventHandlers+=EventHandler*
		public Assignment getEventHandlersAssignment_4() { return cEventHandlersAssignment_4; }
		
		//EventHandler
		public RuleCall getEventHandlersEventHandlerParserRuleCall_4_0() { return cEventHandlersEventHandlerParserRuleCall_4_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_5() { return cENDTerminalRuleCall_5; }
	}
	public class EntityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Entity");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cSpriteKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Action cSpriteEntityAction_0_1 = (Action)cGroup_0.eContents().get(1);
		private final Assignment cNameAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_0_2_0 = (RuleCall)cNameAssignment_0_2.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cSceneKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Action cSceneEntityAction_1_1 = (Action)cGroup_1.eContents().get(1);
		
		//Entity:
		//	'sprite' {SpriteEntity} name=ID | 'scene' {SceneEntity};
		@Override public ParserRule getRule() { return rule; }
		
		//'sprite' {SpriteEntity} name=ID | 'scene' {SceneEntity}
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'sprite' {SpriteEntity} name=ID
		public Group getGroup_0() { return cGroup_0; }
		
		//'sprite'
		public Keyword getSpriteKeyword_0_0() { return cSpriteKeyword_0_0; }
		
		//{SpriteEntity}
		public Action getSpriteEntityAction_0_1() { return cSpriteEntityAction_0_1; }
		
		//name=ID
		public Assignment getNameAssignment_0_2() { return cNameAssignment_0_2; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_2_0() { return cNameIDTerminalRuleCall_0_2_0; }
		
		//'scene' {SceneEntity}
		public Group getGroup_1() { return cGroup_1; }
		
		//'scene'
		public Keyword getSceneKeyword_1_0() { return cSceneKeyword_1_0; }
		
		//{SceneEntity}
		public Action getSceneEntityAction_1_1() { return cSceneEntityAction_1_1; }
	}
	public class EventHandlerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.EventHandler");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cGameStartParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSpriteClickedParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cKeyPressedParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cCollidesWithParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//EventHandler:
		//	GameStart | SpriteClicked | KeyPressed | CollidesWith;
		@Override public ParserRule getRule() { return rule; }
		
		//GameStart | SpriteClicked | KeyPressed | CollidesWith
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//GameStart
		public RuleCall getGameStartParserRuleCall_0() { return cGameStartParserRuleCall_0; }
		
		//SpriteClicked
		public RuleCall getSpriteClickedParserRuleCall_1() { return cSpriteClickedParserRuleCall_1; }
		
		//KeyPressed
		public RuleCall getKeyPressedParserRuleCall_2() { return cKeyPressedParserRuleCall_2; }
		
		//CollidesWith
		public RuleCall getCollidesWithParserRuleCall_3() { return cCollidesWithParserRuleCall_3; }
	}
	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cWhileLoopParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cIfParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cVariableAssignmentParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cForeverLoopParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cFunctionCallParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cSleepParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		//Statement:
		//	WhileLoop | If | VariableAssignment | ForeverLoop | FunctionCall | Sleep;
		@Override public ParserRule getRule() { return rule; }
		
		//WhileLoop | If | VariableAssignment | ForeverLoop | FunctionCall | Sleep
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//WhileLoop
		public RuleCall getWhileLoopParserRuleCall_0() { return cWhileLoopParserRuleCall_0; }
		
		//If
		public RuleCall getIfParserRuleCall_1() { return cIfParserRuleCall_1; }
		
		//VariableAssignment
		public RuleCall getVariableAssignmentParserRuleCall_2() { return cVariableAssignmentParserRuleCall_2; }
		
		//ForeverLoop
		public RuleCall getForeverLoopParserRuleCall_3() { return cForeverLoopParserRuleCall_3; }
		
		//FunctionCall
		public RuleCall getFunctionCallParserRuleCall_4() { return cFunctionCallParserRuleCall_4; }
		
		//Sleep
		public RuleCall getSleepParserRuleCall_5() { return cSleepParserRuleCall_5; }
	}
	public class GameStartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.GameStart");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cGameStartAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cWhenKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cGameKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cStartsKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final RuleCall cBEGINTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		private final Assignment cStatementsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cStatementsStatementParserRuleCall_5_0 = (RuleCall)cStatementsAssignment_5.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_6 = (RuleCall)cGroup.eContents().get(6);
		
		//GameStart EventHandler:
		//	{GameStart}
		//	'when' 'game' 'starts'
		//	BEGIN
		//	statements+=Statement*
		//	END
		@Override public ParserRule getRule() { return rule; }
		
		//{GameStart} 'when' 'game' 'starts' BEGIN statements+=Statement* END
		public Group getGroup() { return cGroup; }
		
		//{GameStart}
		public Action getGameStartAction_0() { return cGameStartAction_0; }
		
		//'when'
		public Keyword getWhenKeyword_1() { return cWhenKeyword_1; }
		
		//'game'
		public Keyword getGameKeyword_2() { return cGameKeyword_2; }
		
		//'starts'
		public Keyword getStartsKeyword_3() { return cStartsKeyword_3; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_4() { return cBEGINTerminalRuleCall_4; }
		
		//statements+=Statement*
		public Assignment getStatementsAssignment_5() { return cStatementsAssignment_5; }
		
		//Statement
		public RuleCall getStatementsStatementParserRuleCall_5_0() { return cStatementsStatementParserRuleCall_5_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_6() { return cENDTerminalRuleCall_6; }
	}
	public class SpriteClickedElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.SpriteClicked");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSpriteClickedAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cWhenKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cClickedKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final RuleCall cBEGINTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Assignment cStatementsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cStatementsStatementParserRuleCall_4_0 = (RuleCall)cStatementsAssignment_4.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		
		//SpriteClicked EventHandler:
		//	{SpriteClicked}
		//	'when' 'clicked'
		//	BEGIN
		//	statements+=Statement*
		//	END
		@Override public ParserRule getRule() { return rule; }
		
		//{SpriteClicked} 'when' 'clicked' BEGIN statements+=Statement* END
		public Group getGroup() { return cGroup; }
		
		//{SpriteClicked}
		public Action getSpriteClickedAction_0() { return cSpriteClickedAction_0; }
		
		//'when'
		public Keyword getWhenKeyword_1() { return cWhenKeyword_1; }
		
		//'clicked'
		public Keyword getClickedKeyword_2() { return cClickedKeyword_2; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_3() { return cBEGINTerminalRuleCall_3; }
		
		//statements+=Statement*
		public Assignment getStatementsAssignment_4() { return cStatementsAssignment_4; }
		
		//Statement
		public RuleCall getStatementsStatementParserRuleCall_4_0() { return cStatementsStatementParserRuleCall_4_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_5() { return cENDTerminalRuleCall_5; }
	}
	public class KeyPressedElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.KeyPressed");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cKeyPressedAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cWhenKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cKeyAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cKeyUPPERCASETerminalRuleCall_2_0 = (RuleCall)cKeyAssignment_2.eContents().get(0);
		private final Keyword cKeyKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cPressedKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final RuleCall cBEGINTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		private final Assignment cStatementsAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cStatementsStatementParserRuleCall_6_0 = (RuleCall)cStatementsAssignment_6.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_7 = (RuleCall)cGroup.eContents().get(7);
		
		//KeyPressed EventHandler:
		//	{KeyPressed}
		//	'when' key=UPPERCASE 'key' 'pressed'
		//	BEGIN
		//	statements+=Statement*
		//	END
		@Override public ParserRule getRule() { return rule; }
		
		//{KeyPressed} 'when' key=UPPERCASE 'key' 'pressed' BEGIN statements+=Statement* END
		public Group getGroup() { return cGroup; }
		
		//{KeyPressed}
		public Action getKeyPressedAction_0() { return cKeyPressedAction_0; }
		
		//'when'
		public Keyword getWhenKeyword_1() { return cWhenKeyword_1; }
		
		//key=UPPERCASE
		public Assignment getKeyAssignment_2() { return cKeyAssignment_2; }
		
		//UPPERCASE
		public RuleCall getKeyUPPERCASETerminalRuleCall_2_0() { return cKeyUPPERCASETerminalRuleCall_2_0; }
		
		//'key'
		public Keyword getKeyKeyword_3() { return cKeyKeyword_3; }
		
		//'pressed'
		public Keyword getPressedKeyword_4() { return cPressedKeyword_4; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_5() { return cBEGINTerminalRuleCall_5; }
		
		//statements+=Statement*
		public Assignment getStatementsAssignment_6() { return cStatementsAssignment_6; }
		
		//Statement
		public RuleCall getStatementsStatementParserRuleCall_6_0() { return cStatementsStatementParserRuleCall_6_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_7() { return cENDTerminalRuleCall_7; }
	}
	public class CollidesWithElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.CollidesWith");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCollidesWithAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cWhenKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cCollidesKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cWithKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cTargetAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final CrossReference cTargetSpriteEntityCrossReference_4_0 = (CrossReference)cTargetAssignment_4.eContents().get(0);
		private final RuleCall cTargetSpriteEntityIDTerminalRuleCall_4_0_1 = (RuleCall)cTargetSpriteEntityCrossReference_4_0.eContents().get(1);
		private final RuleCall cBEGINTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		private final Assignment cStatementsAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cStatementsStatementParserRuleCall_6_0 = (RuleCall)cStatementsAssignment_6.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_7 = (RuleCall)cGroup.eContents().get(7);
		
		//CollidesWith EventHandler:
		//	{CollidesWith}
		//	'when' 'collides' 'with' target=[SpriteEntity] BEGIN
		//	statements+=Statement*
		//	END
		@Override public ParserRule getRule() { return rule; }
		
		//{CollidesWith} 'when' 'collides' 'with' target=[SpriteEntity] BEGIN statements+=Statement* END
		public Group getGroup() { return cGroup; }
		
		//{CollidesWith}
		public Action getCollidesWithAction_0() { return cCollidesWithAction_0; }
		
		//'when'
		public Keyword getWhenKeyword_1() { return cWhenKeyword_1; }
		
		//'collides'
		public Keyword getCollidesKeyword_2() { return cCollidesKeyword_2; }
		
		//'with'
		public Keyword getWithKeyword_3() { return cWithKeyword_3; }
		
		//target=[SpriteEntity]
		public Assignment getTargetAssignment_4() { return cTargetAssignment_4; }
		
		//[SpriteEntity]
		public CrossReference getTargetSpriteEntityCrossReference_4_0() { return cTargetSpriteEntityCrossReference_4_0; }
		
		//ID
		public RuleCall getTargetSpriteEntityIDTerminalRuleCall_4_0_1() { return cTargetSpriteEntityIDTerminalRuleCall_4_0_1; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_5() { return cBEGINTerminalRuleCall_5; }
		
		//statements+=Statement*
		public Assignment getStatementsAssignment_6() { return cStatementsAssignment_6; }
		
		//Statement
		public RuleCall getStatementsStatementParserRuleCall_6_0() { return cStatementsStatementParserRuleCall_6_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_7() { return cENDTerminalRuleCall_7; }
	}
	public class WhileLoopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.WhileLoop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cWhileLoopAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cWhileKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cPredicateAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPredicateExpressionParserRuleCall_2_0 = (RuleCall)cPredicateAssignment_2.eContents().get(0);
		private final RuleCall cBEGINTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Assignment cLoopBlockAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cLoopBlockStatementParserRuleCall_4_0 = (RuleCall)cLoopBlockAssignment_4.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		
		//WhileLoop Statement:
		//	{WhileLoop}
		//	'while' predicate=Expression
		//	BEGIN
		//	loopBlock+=Statement*
		//	END
		@Override public ParserRule getRule() { return rule; }
		
		//{WhileLoop} 'while' predicate=Expression BEGIN loopBlock+=Statement* END
		public Group getGroup() { return cGroup; }
		
		//{WhileLoop}
		public Action getWhileLoopAction_0() { return cWhileLoopAction_0; }
		
		//'while'
		public Keyword getWhileKeyword_1() { return cWhileKeyword_1; }
		
		//predicate=Expression
		public Assignment getPredicateAssignment_2() { return cPredicateAssignment_2; }
		
		//Expression
		public RuleCall getPredicateExpressionParserRuleCall_2_0() { return cPredicateExpressionParserRuleCall_2_0; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_3() { return cBEGINTerminalRuleCall_3; }
		
		//loopBlock+=Statement*
		public Assignment getLoopBlockAssignment_4() { return cLoopBlockAssignment_4; }
		
		//Statement
		public RuleCall getLoopBlockStatementParserRuleCall_4_0() { return cLoopBlockStatementParserRuleCall_4_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_5() { return cENDTerminalRuleCall_5; }
	}
	public class IfElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.If");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cIfAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cIfKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cPredicateAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPredicateExpressionParserRuleCall_2_0 = (RuleCall)cPredicateAssignment_2.eContents().get(0);
		private final RuleCall cBEGINTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Assignment cIfBlockAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cIfBlockStatementParserRuleCall_4_0 = (RuleCall)cIfBlockAssignment_4.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		
		//If Statement:
		//	{If}
		//	'if' predicate=Expression
		//	BEGIN
		//	ifBlock+=Statement*
		//	END
		@Override public ParserRule getRule() { return rule; }
		
		//{If} 'if' predicate=Expression BEGIN ifBlock+=Statement* END
		public Group getGroup() { return cGroup; }
		
		//{If}
		public Action getIfAction_0() { return cIfAction_0; }
		
		//'if'
		public Keyword getIfKeyword_1() { return cIfKeyword_1; }
		
		//predicate=Expression
		public Assignment getPredicateAssignment_2() { return cPredicateAssignment_2; }
		
		//Expression
		public RuleCall getPredicateExpressionParserRuleCall_2_0() { return cPredicateExpressionParserRuleCall_2_0; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_3() { return cBEGINTerminalRuleCall_3; }
		
		//ifBlock+=Statement*
		public Assignment getIfBlockAssignment_4() { return cIfBlockAssignment_4; }
		
		//Statement
		public RuleCall getIfBlockStatementParserRuleCall_4_0() { return cIfBlockStatementParserRuleCall_4_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_5() { return cENDTerminalRuleCall_5; }
	}
	public class ForeverLoopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.ForeverLoop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cForeverLoopAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cForeverKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cBEGINTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cLoopStatementsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cLoopStatementsStatementParserRuleCall_3_0 = (RuleCall)cLoopStatementsAssignment_3.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		//ForeverLoop Statement:
		//	{ForeverLoop}
		//	'forever'
		//	BEGIN
		//	loopStatements+=Statement*
		//	END
		@Override public ParserRule getRule() { return rule; }
		
		//{ForeverLoop} 'forever' BEGIN loopStatements+=Statement* END
		public Group getGroup() { return cGroup; }
		
		//{ForeverLoop}
		public Action getForeverLoopAction_0() { return cForeverLoopAction_0; }
		
		//'forever'
		public Keyword getForeverKeyword_1() { return cForeverKeyword_1; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_2() { return cBEGINTerminalRuleCall_2; }
		
		//loopStatements+=Statement*
		public Assignment getLoopStatementsAssignment_3() { return cLoopStatementsAssignment_3; }
		
		//Statement
		public RuleCall getLoopStatementsStatementParserRuleCall_3_0() { return cLoopStatementsStatementParserRuleCall_3_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_4() { return cENDTerminalRuleCall_4; }
	}
	public class VariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Variable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cVarKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cExpressionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cExpressionExpressionParserRuleCall_3_0 = (RuleCall)cExpressionAssignment_3.eContents().get(0);
		
		//Variable:
		//	'var' name=ID '=' expression=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//'var' name=ID '=' expression=Expression
		public Group getGroup() { return cGroup; }
		
		//'var'
		public Keyword getVarKeyword_0() { return cVarKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_3() { return cExpressionAssignment_3; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_3_0() { return cExpressionExpressionParserRuleCall_3_0; }
	}
	public class AbstractElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.AbstractElement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVariableAssignmentParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//AbstractElement:
		//	VariableAssignment | Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//VariableAssignment | Expression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//VariableAssignment
		public RuleCall getVariableAssignmentParserRuleCall_0() { return cVariableAssignmentParserRuleCall_0; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_1() { return cExpressionParserRuleCall_1; }
	}
	public class VariableAssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.VariableAssignment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVariableNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVariableNameIDTerminalRuleCall_0_0 = (RuleCall)cVariableNameAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionExpressionParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		
		//VariableAssignment:
		//	variableName=ID '=' expression=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//variableName=ID '=' expression=Expression
		public Group getGroup() { return cGroup; }
		
		//variableName=ID
		public Assignment getVariableNameAssignment_0() { return cVariableNameAssignment_0; }
		
		//ID
		public RuleCall getVariableNameIDTerminalRuleCall_0_0() { return cVariableNameIDTerminalRuleCall_0_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_0() { return cExpressionExpressionParserRuleCall_2_0; }
	}
	public class SleepElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Sleep");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSleepAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cSleepKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cDurationAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cDurationDECIMALTerminalRuleCall_3_0 = (RuleCall)cDurationAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Sleep Statement:
		//	{Sleep}
		//	'sleep' '(' duration=DECIMAL ')'
		@Override public ParserRule getRule() { return rule; }
		
		//{Sleep} 'sleep' '(' duration=DECIMAL ')'
		public Group getGroup() { return cGroup; }
		
		//{Sleep}
		public Action getSleepAction_0() { return cSleepAction_0; }
		
		//'sleep'
		public Keyword getSleepKeyword_1() { return cSleepKeyword_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//duration=DECIMAL
		public Assignment getDurationAssignment_3() { return cDurationAssignment_3; }
		
		//DECIMAL
		public RuleCall getDurationDECIMALTerminalRuleCall_3_0() { return cDurationDECIMALTerminalRuleCall_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Expression");
		private final RuleCall cOrParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Expression:
		//	Or;
		@Override public ParserRule getRule() { return rule; }
		
		//Or
		public RuleCall getOrParserRuleCall() { return cOrParserRuleCall; }
	}
	public class OrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Or");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cOrKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAndParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Or Expression:
		//	And ({Or.left=current} 'or' right=And)*
		@Override public ParserRule getRule() { return rule; }
		
		//And ({Or.left=current} 'or' right=And)*
		public Group getGroup() { return cGroup; }
		
		//And
		public RuleCall getAndParserRuleCall_0() { return cAndParserRuleCall_0; }
		
		//({Or.left=current} 'or' right=And)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Or.left=current}
		public Action getOrLeftAction_1_0() { return cOrLeftAction_1_0; }
		
		//'or'
		public Keyword getOrKeyword_1_1() { return cOrKeyword_1_1; }
		
		//right=And
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//And
		public RuleCall getRightAndParserRuleCall_1_2_0() { return cRightAndParserRuleCall_1_2_0; }
	}
	public class AndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.And");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cComparisonParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAndKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightComparisonParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//And Expression:
		//	Comparison ({And.left=current} 'and' right=Comparison)*
		@Override public ParserRule getRule() { return rule; }
		
		//Comparison ({And.left=current} 'and' right=Comparison)*
		public Group getGroup() { return cGroup; }
		
		//Comparison
		public RuleCall getComparisonParserRuleCall_0() { return cComparisonParserRuleCall_0; }
		
		//({And.left=current} 'and' right=Comparison)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{And.left=current}
		public Action getAndLeftAction_1_0() { return cAndLeftAction_1_0; }
		
		//'and'
		public Keyword getAndKeyword_1_1() { return cAndKeyword_1_1; }
		
		//right=Comparison
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Comparison
		public RuleCall getRightComparisonParserRuleCall_1_2_0() { return cRightComparisonParserRuleCall_1_2_0; }
	}
	public class PlusElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Plus");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMinusParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cPlusLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightMinusParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Plus Expression:
		//	Minus ({Plus.left=current} '+' right=Minus)*
		@Override public ParserRule getRule() { return rule; }
		
		//Minus ({Plus.left=current} '+' right=Minus)*
		public Group getGroup() { return cGroup; }
		
		//Minus
		public RuleCall getMinusParserRuleCall_0() { return cMinusParserRuleCall_0; }
		
		//({Plus.left=current} '+' right=Minus)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Plus.left=current}
		public Action getPlusLeftAction_1_0() { return cPlusLeftAction_1_0; }
		
		//'+'
		public Keyword getPlusSignKeyword_1_1() { return cPlusSignKeyword_1_1; }
		
		//right=Minus
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Minus
		public RuleCall getRightMinusParserRuleCall_1_2_0() { return cRightMinusParserRuleCall_1_2_0; }
	}
	public class MinusElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Minus");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplyParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMinusLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightMultiplyParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Minus Expression:
		//	Multiply ({Minus.left=current} '-' right=Multiply)*
		@Override public ParserRule getRule() { return rule; }
		
		//Multiply ({Minus.left=current} '-' right=Multiply)*
		public Group getGroup() { return cGroup; }
		
		//Multiply
		public RuleCall getMultiplyParserRuleCall_0() { return cMultiplyParserRuleCall_0; }
		
		//({Minus.left=current} '-' right=Multiply)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Minus.left=current}
		public Action getMinusLeftAction_1_0() { return cMinusLeftAction_1_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_1_1() { return cHyphenMinusKeyword_1_1; }
		
		//right=Multiply
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Multiply
		public RuleCall getRightMultiplyParserRuleCall_1_2_0() { return cRightMultiplyParserRuleCall_1_2_0; }
	}
	public class MultiplyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Multiply");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cDivideParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMultiplyLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAsteriskKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightDivideParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Multiply Expression:
		//	Divide ({Multiply.left=current} '*' right=Divide)*
		@Override public ParserRule getRule() { return rule; }
		
		//Divide ({Multiply.left=current} '*' right=Divide)*
		public Group getGroup() { return cGroup; }
		
		//Divide
		public RuleCall getDivideParserRuleCall_0() { return cDivideParserRuleCall_0; }
		
		//({Multiply.left=current} '*' right=Divide)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Multiply.left=current}
		public Action getMultiplyLeftAction_1_0() { return cMultiplyLeftAction_1_0; }
		
		//'*'
		public Keyword getAsteriskKeyword_1_1() { return cAsteriskKeyword_1_1; }
		
		//right=Divide
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Divide
		public RuleCall getRightDivideParserRuleCall_1_2_0() { return cRightDivideParserRuleCall_1_2_0; }
	}
	public class DivideElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Divide");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cDivideLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cSolidusKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPrimaryExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Divide Expression:
		//	PrimaryExpression ({Divide.left=current} '/' right=PrimaryExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//PrimaryExpression ({Divide.left=current} '/' right=PrimaryExpression)*
		public Group getGroup() { return cGroup; }
		
		//PrimaryExpression
		public RuleCall getPrimaryExpressionParserRuleCall_0() { return cPrimaryExpressionParserRuleCall_0; }
		
		//({Divide.left=current} '/' right=PrimaryExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Divide.left=current}
		public Action getDivideLeftAction_1_0() { return cDivideLeftAction_1_0; }
		
		//'/'
		public Keyword getSolidusKeyword_1_1() { return cSolidusKeyword_1_1; }
		
		//right=PrimaryExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//PrimaryExpression
		public RuleCall getRightPrimaryExpressionParserRuleCall_1_2_0() { return cRightPrimaryExpressionParserRuleCall_1_2_0; }
	}
	public class ComparisonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Comparison");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPlusParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Keyword cLessThanSignKeyword_1_0_0_0 = (Keyword)cGroup_1_0_0.eContents().get(0);
		private final Action cLessThanLeftAction_1_0_0_1 = (Action)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Keyword cEqualsSignEqualsSignKeyword_1_0_1_0 = (Keyword)cGroup_1_0_1.eContents().get(0);
		private final Action cEqualLeftAction_1_0_1_1 = (Action)cGroup_1_0_1.eContents().get(1);
		private final Group cGroup_1_0_2 = (Group)cAlternatives_1_0.eContents().get(2);
		private final Keyword cGreaterThanSignKeyword_1_0_2_0 = (Keyword)cGroup_1_0_2.eContents().get(0);
		private final Action cGreaterThanLeftAction_1_0_2_1 = (Action)cGroup_1_0_2.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightPlusParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//Comparison Expression:
		//	Plus (('<' {LessThan.left=current} | '==' {Equal.left=current} | '>' {GreaterThan.left=current}) right=Plus)*
		@Override public ParserRule getRule() { return rule; }
		
		//Plus (('<' {LessThan.left=current} | '==' {Equal.left=current} | '>' {GreaterThan.left=current}) right=Plus)*
		public Group getGroup() { return cGroup; }
		
		//Plus
		public RuleCall getPlusParserRuleCall_0() { return cPlusParserRuleCall_0; }
		
		//(('<' {LessThan.left=current} | '==' {Equal.left=current} | '>' {GreaterThan.left=current}) right=Plus)*
		public Group getGroup_1() { return cGroup_1; }
		
		//('<' {LessThan.left=current} | '==' {Equal.left=current} | '>' {GreaterThan.left=current})
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }
		
		//'<' {LessThan.left=current}
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//'<'
		public Keyword getLessThanSignKeyword_1_0_0_0() { return cLessThanSignKeyword_1_0_0_0; }
		
		//{LessThan.left=current}
		public Action getLessThanLeftAction_1_0_0_1() { return cLessThanLeftAction_1_0_0_1; }
		
		//'==' {Equal.left=current}
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }
		
		//'=='
		public Keyword getEqualsSignEqualsSignKeyword_1_0_1_0() { return cEqualsSignEqualsSignKeyword_1_0_1_0; }
		
		//{Equal.left=current}
		public Action getEqualLeftAction_1_0_1_1() { return cEqualLeftAction_1_0_1_1; }
		
		//'>' {GreaterThan.left=current}
		public Group getGroup_1_0_2() { return cGroup_1_0_2; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword_1_0_2_0() { return cGreaterThanSignKeyword_1_0_2_0; }
		
		//{GreaterThan.left=current}
		public Action getGreaterThanLeftAction_1_0_2_1() { return cGreaterThanLeftAction_1_0_2_1; }
		
		//right=Plus
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//Plus
		public RuleCall getRightPlusParserRuleCall_1_1_0() { return cRightPlusParserRuleCall_1_1_0; }
	}
	public class FunctionCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.FunctionCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cParametersAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cParametersExpressionParserRuleCall_2_0_0 = (RuleCall)cParametersAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cParametersAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cParametersExpressionParserRuleCall_2_1_1_0 = (RuleCall)cParametersAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//FunctionCall:
		//	name=ID '(' (parameters+=Expression (',' parameters+=Expression)*)? ')';
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID '(' (parameters+=Expression (',' parameters+=Expression)*)? ')'
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//(parameters+=Expression (',' parameters+=Expression)*)?
		public Group getGroup_2() { return cGroup_2; }
		
		//parameters+=Expression
		public Assignment getParametersAssignment_2_0() { return cParametersAssignment_2_0; }
		
		//Expression
		public RuleCall getParametersExpressionParserRuleCall_2_0_0() { return cParametersExpressionParserRuleCall_2_0_0; }
		
		//(',' parameters+=Expression)*
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//','
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }
		
		//parameters+=Expression
		public Assignment getParametersAssignment_2_1_1() { return cParametersAssignment_2_1_1; }
		
		//Expression
		public RuleCall getParametersExpressionParserRuleCall_2_1_1_0() { return cParametersExpressionParserRuleCall_2_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class PrimaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.PrimaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cNotAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cNotKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cExpressionPrimaryExpressionParserRuleCall_1_2_0 = (RuleCall)cExpressionAssignment_1_2.eContents().get(0);
		private final RuleCall cFunctionCallParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cAtomicExpressionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//PrimaryExpression Expression:
		//	'(' Expression ')' | {Not} 'not' expression=PrimaryExpression | FunctionCall | AtomicExpression
		@Override public ParserRule getRule() { return rule; }
		
		//'(' Expression ')' | {Not} 'not' expression=PrimaryExpression | FunctionCall | AtomicExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'(' Expression ')'
		public Group getGroup_0() { return cGroup_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_0_1() { return cExpressionParserRuleCall_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }
		
		//{Not} 'not' expression=PrimaryExpression
		public Group getGroup_1() { return cGroup_1; }
		
		//{Not}
		public Action getNotAction_1_0() { return cNotAction_1_0; }
		
		//'not'
		public Keyword getNotKeyword_1_1() { return cNotKeyword_1_1; }
		
		//expression=PrimaryExpression
		public Assignment getExpressionAssignment_1_2() { return cExpressionAssignment_1_2; }
		
		//PrimaryExpression
		public RuleCall getExpressionPrimaryExpressionParserRuleCall_1_2_0() { return cExpressionPrimaryExpressionParserRuleCall_1_2_0; }
		
		//FunctionCall
		public RuleCall getFunctionCallParserRuleCall_2() { return cFunctionCallParserRuleCall_2; }
		
		//AtomicExpression
		public RuleCall getAtomicExpressionParserRuleCall_3() { return cAtomicExpressionParserRuleCall_3; }
	}
	public class AtomicExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.AtomicExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cBooleanLiteralAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Alternatives cAlternatives_0_1 = (Alternatives)cGroup_0.eContents().get(1);
		private final Assignment cValueAssignment_0_1_0 = (Assignment)cAlternatives_0_1.eContents().get(0);
		private final Keyword cValueTrueKeyword_0_1_0_0 = (Keyword)cValueAssignment_0_1_0.eContents().get(0);
		private final Keyword cFalseKeyword_0_1_1 = (Keyword)cAlternatives_0_1.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cDoubleLiteralAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValueDECIMALTerminalRuleCall_1_1_0 = (RuleCall)cValueAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cStringLiteralAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Assignment cValueAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_2_1_0 = (RuleCall)cValueAssignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cVariableRefAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final Assignment cVariableNameAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cVariableNameIDTerminalRuleCall_3_1_0 = (RuleCall)cVariableNameAssignment_3_1.eContents().get(0);
		
		//AtomicExpression Expression:
		//	{BooleanLiteral} (value?='true' | 'false') | {DoubleLiteral} value=DECIMAL | {StringLiteral} value=STRING |
		//	{VariableRef} variableName=ID
		@Override public ParserRule getRule() { return rule; }
		
		//{BooleanLiteral} (value?='true' | 'false') | {DoubleLiteral} value=DECIMAL | {StringLiteral} value=STRING |
		//{VariableRef} variableName=ID
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{BooleanLiteral} (value?='true' | 'false')
		public Group getGroup_0() { return cGroup_0; }
		
		//{BooleanLiteral}
		public Action getBooleanLiteralAction_0_0() { return cBooleanLiteralAction_0_0; }
		
		//(value?='true' | 'false')
		public Alternatives getAlternatives_0_1() { return cAlternatives_0_1; }
		
		//value?='true'
		public Assignment getValueAssignment_0_1_0() { return cValueAssignment_0_1_0; }
		
		//'true'
		public Keyword getValueTrueKeyword_0_1_0_0() { return cValueTrueKeyword_0_1_0_0; }
		
		//'false'
		public Keyword getFalseKeyword_0_1_1() { return cFalseKeyword_0_1_1; }
		
		//{DoubleLiteral} value=DECIMAL
		public Group getGroup_1() { return cGroup_1; }
		
		//{DoubleLiteral}
		public Action getDoubleLiteralAction_1_0() { return cDoubleLiteralAction_1_0; }
		
		//value=DECIMAL
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }
		
		//DECIMAL
		public RuleCall getValueDECIMALTerminalRuleCall_1_1_0() { return cValueDECIMALTerminalRuleCall_1_1_0; }
		
		//{StringLiteral} value=STRING
		public Group getGroup_2() { return cGroup_2; }
		
		//{StringLiteral}
		public Action getStringLiteralAction_2_0() { return cStringLiteralAction_2_0; }
		
		//value=STRING
		public Assignment getValueAssignment_2_1() { return cValueAssignment_2_1; }
		
		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_2_1_0() { return cValueSTRINGTerminalRuleCall_2_1_0; }
		
		//{VariableRef} variableName=ID
		public Group getGroup_3() { return cGroup_3; }
		
		//{VariableRef}
		public Action getVariableRefAction_3_0() { return cVariableRefAction_3_0; }
		
		//variableName=ID
		public Assignment getVariableNameAssignment_3_1() { return cVariableNameAssignment_3_1; }
		
		//ID
		public RuleCall getVariableNameIDTerminalRuleCall_3_1_0() { return cVariableNameIDTerminalRuleCall_3_1_0; }
	}
	
	
	private final GameElements pGame;
	private final ActorElements pActor;
	private final EntityElements pEntity;
	private final EventHandlerElements pEventHandler;
	private final StatementElements pStatement;
	private final GameStartElements pGameStart;
	private final SpriteClickedElements pSpriteClicked;
	private final KeyPressedElements pKeyPressed;
	private final CollidesWithElements pCollidesWith;
	private final WhileLoopElements pWhileLoop;
	private final IfElements pIf;
	private final ForeverLoopElements pForeverLoop;
	private final VariableElements pVariable;
	private final AbstractElementElements pAbstractElement;
	private final VariableAssignmentElements pVariableAssignment;
	private final SleepElements pSleep;
	private final ExpressionElements pExpression;
	private final OrElements pOr;
	private final AndElements pAnd;
	private final PlusElements pPlus;
	private final MinusElements pMinus;
	private final MultiplyElements pMultiply;
	private final DivideElements pDivide;
	private final ComparisonElements pComparison;
	private final FunctionCallElements pFunctionCall;
	private final PrimaryExpressionElements pPrimaryExpression;
	private final AtomicExpressionElements pAtomicExpression;
	private final TerminalRule tBEGIN;
	private final TerminalRule tEND;
	private final TerminalRule tUPPERCASE;
	private final TerminalRule tDECIMAL;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public KlangGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pGame = new GameElements();
		this.pActor = new ActorElements();
		this.pEntity = new EntityElements();
		this.pEventHandler = new EventHandlerElements();
		this.pStatement = new StatementElements();
		this.pGameStart = new GameStartElements();
		this.pSpriteClicked = new SpriteClickedElements();
		this.pKeyPressed = new KeyPressedElements();
		this.pCollidesWith = new CollidesWithElements();
		this.pWhileLoop = new WhileLoopElements();
		this.pIf = new IfElements();
		this.pForeverLoop = new ForeverLoopElements();
		this.pVariable = new VariableElements();
		this.pAbstractElement = new AbstractElementElements();
		this.pVariableAssignment = new VariableAssignmentElements();
		this.pSleep = new SleepElements();
		this.pExpression = new ExpressionElements();
		this.pOr = new OrElements();
		this.pAnd = new AndElements();
		this.pPlus = new PlusElements();
		this.pMinus = new MinusElements();
		this.pMultiply = new MultiplyElements();
		this.pDivide = new DivideElements();
		this.pComparison = new ComparisonElements();
		this.pFunctionCall = new FunctionCallElements();
		this.pPrimaryExpression = new PrimaryExpressionElements();
		this.pAtomicExpression = new AtomicExpressionElements();
		this.tBEGIN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.BEGIN");
		this.tEND = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.END");
		this.tUPPERCASE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.UPPERCASE");
		this.tDECIMAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.DECIMAL");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("com.kaurel.klang.xtext.Klang".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Game:
	//	{Game} variableDeclarations+=Variable*
	//	actorDefs+=Actor*;
	public GameElements getGameAccess() {
		return pGame;
	}
	
	public ParserRule getGameRule() {
		return getGameAccess().getRule();
	}
	
	//Actor:
	//	{Actor} entity=Entity
	//	BEGIN
	//	variableDeclarations+=Variable*
	//	eventHandlers+=EventHandler*
	//	END;
	public ActorElements getActorAccess() {
		return pActor;
	}
	
	public ParserRule getActorRule() {
		return getActorAccess().getRule();
	}
	
	//Entity:
	//	'sprite' {SpriteEntity} name=ID | 'scene' {SceneEntity};
	public EntityElements getEntityAccess() {
		return pEntity;
	}
	
	public ParserRule getEntityRule() {
		return getEntityAccess().getRule();
	}
	
	//EventHandler:
	//	GameStart | SpriteClicked | KeyPressed | CollidesWith;
	public EventHandlerElements getEventHandlerAccess() {
		return pEventHandler;
	}
	
	public ParserRule getEventHandlerRule() {
		return getEventHandlerAccess().getRule();
	}
	
	//Statement:
	//	WhileLoop | If | VariableAssignment | ForeverLoop | FunctionCall | Sleep;
	public StatementElements getStatementAccess() {
		return pStatement;
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}
	
	//GameStart EventHandler:
	//	{GameStart}
	//	'when' 'game' 'starts'
	//	BEGIN
	//	statements+=Statement*
	//	END
	public GameStartElements getGameStartAccess() {
		return pGameStart;
	}
	
	public ParserRule getGameStartRule() {
		return getGameStartAccess().getRule();
	}
	
	//SpriteClicked EventHandler:
	//	{SpriteClicked}
	//	'when' 'clicked'
	//	BEGIN
	//	statements+=Statement*
	//	END
	public SpriteClickedElements getSpriteClickedAccess() {
		return pSpriteClicked;
	}
	
	public ParserRule getSpriteClickedRule() {
		return getSpriteClickedAccess().getRule();
	}
	
	//KeyPressed EventHandler:
	//	{KeyPressed}
	//	'when' key=UPPERCASE 'key' 'pressed'
	//	BEGIN
	//	statements+=Statement*
	//	END
	public KeyPressedElements getKeyPressedAccess() {
		return pKeyPressed;
	}
	
	public ParserRule getKeyPressedRule() {
		return getKeyPressedAccess().getRule();
	}
	
	//CollidesWith EventHandler:
	//	{CollidesWith}
	//	'when' 'collides' 'with' target=[SpriteEntity] BEGIN
	//	statements+=Statement*
	//	END
	public CollidesWithElements getCollidesWithAccess() {
		return pCollidesWith;
	}
	
	public ParserRule getCollidesWithRule() {
		return getCollidesWithAccess().getRule();
	}
	
	//WhileLoop Statement:
	//	{WhileLoop}
	//	'while' predicate=Expression
	//	BEGIN
	//	loopBlock+=Statement*
	//	END
	public WhileLoopElements getWhileLoopAccess() {
		return pWhileLoop;
	}
	
	public ParserRule getWhileLoopRule() {
		return getWhileLoopAccess().getRule();
	}
	
	//If Statement:
	//	{If}
	//	'if' predicate=Expression
	//	BEGIN
	//	ifBlock+=Statement*
	//	END
	public IfElements getIfAccess() {
		return pIf;
	}
	
	public ParserRule getIfRule() {
		return getIfAccess().getRule();
	}
	
	//ForeverLoop Statement:
	//	{ForeverLoop}
	//	'forever'
	//	BEGIN
	//	loopStatements+=Statement*
	//	END
	public ForeverLoopElements getForeverLoopAccess() {
		return pForeverLoop;
	}
	
	public ParserRule getForeverLoopRule() {
		return getForeverLoopAccess().getRule();
	}
	
	//Variable:
	//	'var' name=ID '=' expression=Expression;
	public VariableElements getVariableAccess() {
		return pVariable;
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}
	
	//AbstractElement:
	//	VariableAssignment | Expression;
	public AbstractElementElements getAbstractElementAccess() {
		return pAbstractElement;
	}
	
	public ParserRule getAbstractElementRule() {
		return getAbstractElementAccess().getRule();
	}
	
	//VariableAssignment:
	//	variableName=ID '=' expression=Expression;
	public VariableAssignmentElements getVariableAssignmentAccess() {
		return pVariableAssignment;
	}
	
	public ParserRule getVariableAssignmentRule() {
		return getVariableAssignmentAccess().getRule();
	}
	
	//Sleep Statement:
	//	{Sleep}
	//	'sleep' '(' duration=DECIMAL ')'
	public SleepElements getSleepAccess() {
		return pSleep;
	}
	
	public ParserRule getSleepRule() {
		return getSleepAccess().getRule();
	}
	
	//Expression:
	//	Or;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//Or Expression:
	//	And ({Or.left=current} 'or' right=And)*
	public OrElements getOrAccess() {
		return pOr;
	}
	
	public ParserRule getOrRule() {
		return getOrAccess().getRule();
	}
	
	//And Expression:
	//	Comparison ({And.left=current} 'and' right=Comparison)*
	public AndElements getAndAccess() {
		return pAnd;
	}
	
	public ParserRule getAndRule() {
		return getAndAccess().getRule();
	}
	
	//Plus Expression:
	//	Minus ({Plus.left=current} '+' right=Minus)*
	public PlusElements getPlusAccess() {
		return pPlus;
	}
	
	public ParserRule getPlusRule() {
		return getPlusAccess().getRule();
	}
	
	//Minus Expression:
	//	Multiply ({Minus.left=current} '-' right=Multiply)*
	public MinusElements getMinusAccess() {
		return pMinus;
	}
	
	public ParserRule getMinusRule() {
		return getMinusAccess().getRule();
	}
	
	//Multiply Expression:
	//	Divide ({Multiply.left=current} '*' right=Divide)*
	public MultiplyElements getMultiplyAccess() {
		return pMultiply;
	}
	
	public ParserRule getMultiplyRule() {
		return getMultiplyAccess().getRule();
	}
	
	//Divide Expression:
	//	PrimaryExpression ({Divide.left=current} '/' right=PrimaryExpression)*
	public DivideElements getDivideAccess() {
		return pDivide;
	}
	
	public ParserRule getDivideRule() {
		return getDivideAccess().getRule();
	}
	
	//Comparison Expression:
	//	Plus (('<' {LessThan.left=current} | '==' {Equal.left=current} | '>' {GreaterThan.left=current}) right=Plus)*
	public ComparisonElements getComparisonAccess() {
		return pComparison;
	}
	
	public ParserRule getComparisonRule() {
		return getComparisonAccess().getRule();
	}
	
	//FunctionCall:
	//	name=ID '(' (parameters+=Expression (',' parameters+=Expression)*)? ')';
	public FunctionCallElements getFunctionCallAccess() {
		return pFunctionCall;
	}
	
	public ParserRule getFunctionCallRule() {
		return getFunctionCallAccess().getRule();
	}
	
	//PrimaryExpression Expression:
	//	'(' Expression ')' | {Not} 'not' expression=PrimaryExpression | FunctionCall | AtomicExpression
	public PrimaryExpressionElements getPrimaryExpressionAccess() {
		return pPrimaryExpression;
	}
	
	public ParserRule getPrimaryExpressionRule() {
		return getPrimaryExpressionAccess().getRule();
	}
	
	//AtomicExpression Expression:
	//	{BooleanLiteral} (value?='true' | 'false') | {DoubleLiteral} value=DECIMAL | {StringLiteral} value=STRING |
	//	{VariableRef} variableName=ID
	public AtomicExpressionElements getAtomicExpressionAccess() {
		return pAtomicExpression;
	}
	
	public ParserRule getAtomicExpressionRule() {
		return getAtomicExpressionAccess().getRule();
	}
	
	//terminal BEGIN:
	//	'synthetic:BEGIN';
	public TerminalRule getBEGINRule() {
		return tBEGIN;
	}
	
	//terminal END:
	//	'synthetic:END';
	public TerminalRule getENDRule() {
		return tEND;
	}
	
	//terminal UPPERCASE:
	//	'A'..'Z' | '0'..'9'*;
	public TerminalRule getUPPERCASERule() {
		return tUPPERCASE;
	}
	
	//terminal DECIMAL returns ecore::EDouble:
	//	INT ('.' INT)?;
	public TerminalRule getDECIMALRule() {
		return tDECIMAL;
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/ *'->'* /';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
