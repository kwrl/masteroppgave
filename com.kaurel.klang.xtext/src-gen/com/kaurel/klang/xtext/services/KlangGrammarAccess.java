/*
 * generated by Xtext 2.10.0-SNAPSHOT
 */
package com.kaurel.klang.xtext.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractEnumRuleElementFinder;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class KlangGrammarAccess extends AbstractGrammarElementFinder {
	
	public class GameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Game");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cGameAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cVariableDeclarationsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVariableDeclarationsVariableParserRuleCall_1_0 = (RuleCall)cVariableDeclarationsAssignment_1.eContents().get(0);
		private final Assignment cActorDefsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cActorDefsActorParserRuleCall_2_0 = (RuleCall)cActorDefsAssignment_2.eContents().get(0);
		
		//Game:
		//	{Game} variableDeclarations+=Variable*
		//	actorDefs+=Actor*;
		@Override public ParserRule getRule() { return rule; }
		
		//{Game} variableDeclarations+=Variable* actorDefs+=Actor*
		public Group getGroup() { return cGroup; }
		
		//{Game}
		public Action getGameAction_0() { return cGameAction_0; }
		
		//variableDeclarations+=Variable*
		public Assignment getVariableDeclarationsAssignment_1() { return cVariableDeclarationsAssignment_1; }
		
		//Variable
		public RuleCall getVariableDeclarationsVariableParserRuleCall_1_0() { return cVariableDeclarationsVariableParserRuleCall_1_0; }
		
		//actorDefs+=Actor*
		public Assignment getActorDefsAssignment_2() { return cActorDefsAssignment_2; }
		
		//Actor
		public RuleCall getActorDefsActorParserRuleCall_2_0() { return cActorDefsActorParserRuleCall_2_0; }
	}
	public class ActorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Actor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cActorAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cEntityAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cEntityEntityParserRuleCall_1_0 = (RuleCall)cEntityAssignment_1.eContents().get(0);
		private final RuleCall cBEGINTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cVariableDeclarationsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cVariableDeclarationsVariableParserRuleCall_3_0 = (RuleCall)cVariableDeclarationsAssignment_3.eContents().get(0);
		private final Assignment cEventHandlersAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cEventHandlersEventHandlerParserRuleCall_4_0 = (RuleCall)cEventHandlersAssignment_4.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		
		//Actor:
		//	{Actor} entity=Entity
		//	BEGIN
		//	variableDeclarations+=Variable*
		//	eventHandlers+=EventHandler*
		//	END;
		@Override public ParserRule getRule() { return rule; }
		
		//{Actor} entity=Entity BEGIN variableDeclarations+=Variable* eventHandlers+=EventHandler* END
		public Group getGroup() { return cGroup; }
		
		//{Actor}
		public Action getActorAction_0() { return cActorAction_0; }
		
		//entity=Entity
		public Assignment getEntityAssignment_1() { return cEntityAssignment_1; }
		
		//Entity
		public RuleCall getEntityEntityParserRuleCall_1_0() { return cEntityEntityParserRuleCall_1_0; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_2() { return cBEGINTerminalRuleCall_2; }
		
		//variableDeclarations+=Variable*
		public Assignment getVariableDeclarationsAssignment_3() { return cVariableDeclarationsAssignment_3; }
		
		//Variable
		public RuleCall getVariableDeclarationsVariableParserRuleCall_3_0() { return cVariableDeclarationsVariableParserRuleCall_3_0; }
		
		//eventHandlers+=EventHandler*
		public Assignment getEventHandlersAssignment_4() { return cEventHandlersAssignment_4; }
		
		//EventHandler
		public RuleCall getEventHandlersEventHandlerParserRuleCall_4_0() { return cEventHandlersEventHandlerParserRuleCall_4_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_5() { return cENDTerminalRuleCall_5; }
	}
	public class EntityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Entity");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cSpriteKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Action cSpriteEntityAction_0_1 = (Action)cGroup_0.eContents().get(1);
		private final Assignment cNameAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_0_2_0 = (RuleCall)cNameAssignment_0_2.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cSceneKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Action cSceneEntityAction_1_1 = (Action)cGroup_1.eContents().get(1);
		
		//Entity:
		//	'sprite' {SpriteEntity} name=ID | 'scene' {SceneEntity};
		@Override public ParserRule getRule() { return rule; }
		
		//'sprite' {SpriteEntity} name=ID | 'scene' {SceneEntity}
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'sprite' {SpriteEntity} name=ID
		public Group getGroup_0() { return cGroup_0; }
		
		//'sprite'
		public Keyword getSpriteKeyword_0_0() { return cSpriteKeyword_0_0; }
		
		//{SpriteEntity}
		public Action getSpriteEntityAction_0_1() { return cSpriteEntityAction_0_1; }
		
		//name=ID
		public Assignment getNameAssignment_0_2() { return cNameAssignment_0_2; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_2_0() { return cNameIDTerminalRuleCall_0_2_0; }
		
		//'scene' {SceneEntity}
		public Group getGroup_1() { return cGroup_1; }
		
		//'scene'
		public Keyword getSceneKeyword_1_0() { return cSceneKeyword_1_0; }
		
		//{SceneEntity}
		public Action getSceneEntityAction_1_1() { return cSceneEntityAction_1_1; }
	}
	public class EventHandlerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.EventHandler");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhenKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cEventTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cEventTypeEventTypeEnumRuleCall_1_0 = (RuleCall)cEventTypeAssignment_1.eContents().get(0);
		private final RuleCall cBEGINTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cStatementsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cStatementsStatementParserRuleCall_3_0 = (RuleCall)cStatementsAssignment_3.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		//EventHandler:
		//	'when'
		//	eventType=EventType
		//	BEGIN
		//	statements+=Statement*
		//	END;
		@Override public ParserRule getRule() { return rule; }
		
		//'when' eventType=EventType BEGIN statements+=Statement* END
		public Group getGroup() { return cGroup; }
		
		//'when'
		public Keyword getWhenKeyword_0() { return cWhenKeyword_0; }
		
		//eventType=EventType
		public Assignment getEventTypeAssignment_1() { return cEventTypeAssignment_1; }
		
		//EventType
		public RuleCall getEventTypeEventTypeEnumRuleCall_1_0() { return cEventTypeEventTypeEnumRuleCall_1_0; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_2() { return cBEGINTerminalRuleCall_2; }
		
		//statements+=Statement*
		public Assignment getStatementsAssignment_3() { return cStatementsAssignment_3; }
		
		//Statement
		public RuleCall getStatementsStatementParserRuleCall_3_0() { return cStatementsStatementParserRuleCall_3_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_4() { return cENDTerminalRuleCall_4; }
	}
	public class WhileLoopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.WhileLoop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cWhileLoopAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cWhileKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cPredicateAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPredicateExpressionParserRuleCall_2_0 = (RuleCall)cPredicateAssignment_2.eContents().get(0);
		private final RuleCall cBEGINTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Assignment cLoopBlockAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cLoopBlockStatementParserRuleCall_4_0 = (RuleCall)cLoopBlockAssignment_4.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		
		//WhileLoop:
		//	{WhileLoop}
		//	'while' predicate=Expression
		//	BEGIN
		//	loopBlock+=Statement*
		//	END;
		@Override public ParserRule getRule() { return rule; }
		
		//{WhileLoop} 'while' predicate=Expression BEGIN loopBlock+=Statement* END
		public Group getGroup() { return cGroup; }
		
		//{WhileLoop}
		public Action getWhileLoopAction_0() { return cWhileLoopAction_0; }
		
		//'while'
		public Keyword getWhileKeyword_1() { return cWhileKeyword_1; }
		
		//predicate=Expression
		public Assignment getPredicateAssignment_2() { return cPredicateAssignment_2; }
		
		//Expression
		public RuleCall getPredicateExpressionParserRuleCall_2_0() { return cPredicateExpressionParserRuleCall_2_0; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_3() { return cBEGINTerminalRuleCall_3; }
		
		//loopBlock+=Statement*
		public Assignment getLoopBlockAssignment_4() { return cLoopBlockAssignment_4; }
		
		//Statement
		public RuleCall getLoopBlockStatementParserRuleCall_4_0() { return cLoopBlockStatementParserRuleCall_4_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_5() { return cENDTerminalRuleCall_5; }
	}
	public class IfElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.If");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cIfAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cIfKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cPredicateAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPredicateExpressionParserRuleCall_2_0 = (RuleCall)cPredicateAssignment_2.eContents().get(0);
		private final RuleCall cBEGINTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Assignment cIfBlockAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cIfBlockStatementParserRuleCall_4_0 = (RuleCall)cIfBlockAssignment_4.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		
		//If:
		//	{If}
		//	'if' predicate=Expression
		//	BEGIN
		//	ifBlock+=Statement*
		//	END;
		@Override public ParserRule getRule() { return rule; }
		
		//{If} 'if' predicate=Expression BEGIN ifBlock+=Statement* END
		public Group getGroup() { return cGroup; }
		
		//{If}
		public Action getIfAction_0() { return cIfAction_0; }
		
		//'if'
		public Keyword getIfKeyword_1() { return cIfKeyword_1; }
		
		//predicate=Expression
		public Assignment getPredicateAssignment_2() { return cPredicateAssignment_2; }
		
		//Expression
		public RuleCall getPredicateExpressionParserRuleCall_2_0() { return cPredicateExpressionParserRuleCall_2_0; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_3() { return cBEGINTerminalRuleCall_3; }
		
		//ifBlock+=Statement*
		public Assignment getIfBlockAssignment_4() { return cIfBlockAssignment_4; }
		
		//Statement
		public RuleCall getIfBlockStatementParserRuleCall_4_0() { return cIfBlockStatementParserRuleCall_4_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_5() { return cENDTerminalRuleCall_5; }
	}
	public class ForeverLoopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.ForeverLoop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cForeverLoopAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cForeverKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cBEGINTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cLoopStatementsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cLoopStatementsStatementParserRuleCall_3_0 = (RuleCall)cLoopStatementsAssignment_3.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		//ForeverLoop:
		//	{ForeverLoop}
		//	'forever'
		//	BEGIN
		//	loopStatements+=Statement*
		//	END;
		@Override public ParserRule getRule() { return rule; }
		
		//{ForeverLoop} 'forever' BEGIN loopStatements+=Statement* END
		public Group getGroup() { return cGroup; }
		
		//{ForeverLoop}
		public Action getForeverLoopAction_0() { return cForeverLoopAction_0; }
		
		//'forever'
		public Keyword getForeverKeyword_1() { return cForeverKeyword_1; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_2() { return cBEGINTerminalRuleCall_2; }
		
		//loopStatements+=Statement*
		public Assignment getLoopStatementsAssignment_3() { return cLoopStatementsAssignment_3; }
		
		//Statement
		public RuleCall getLoopStatementsStatementParserRuleCall_3_0() { return cLoopStatementsStatementParserRuleCall_3_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_4() { return cENDTerminalRuleCall_4; }
	}
	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cControlStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cVariableParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cVariableAssignmentParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Statement:
		//	ControlStatement | Variable | VariableAssignment;
		@Override public ParserRule getRule() { return rule; }
		
		//ControlStatement | Variable | VariableAssignment
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ControlStatement
		public RuleCall getControlStatementParserRuleCall_0() { return cControlStatementParserRuleCall_0; }
		
		//Variable
		public RuleCall getVariableParserRuleCall_1() { return cVariableParserRuleCall_1; }
		
		//VariableAssignment
		public RuleCall getVariableAssignmentParserRuleCall_2() { return cVariableAssignmentParserRuleCall_2; }
	}
	public class ControlStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.ControlStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cForeverLoopParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cWhileLoopParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cYieldParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cIfParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//ControlStatement:
		//	ForeverLoop | WhileLoop | Yield | If;
		@Override public ParserRule getRule() { return rule; }
		
		//ForeverLoop | WhileLoop | Yield | If
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ForeverLoop
		public RuleCall getForeverLoopParserRuleCall_0() { return cForeverLoopParserRuleCall_0; }
		
		//WhileLoop
		public RuleCall getWhileLoopParserRuleCall_1() { return cWhileLoopParserRuleCall_1; }
		
		//Yield
		public RuleCall getYieldParserRuleCall_2() { return cYieldParserRuleCall_2; }
		
		//If
		public RuleCall getIfParserRuleCall_3() { return cIfParserRuleCall_3; }
	}
	public class YieldElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Yield");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cYieldAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cYieldKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//Yield:
		//	{Yield}
		//	'yield';
		@Override public ParserRule getRule() { return rule; }
		
		//{Yield} 'yield'
		public Group getGroup() { return cGroup; }
		
		//{Yield}
		public Action getYieldAction_0() { return cYieldAction_0; }
		
		//'yield'
		public Keyword getYieldKeyword_1() { return cYieldKeyword_1; }
	}
	public class VariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Variable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cVarKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cExpressionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cExpressionExpressionParserRuleCall_3_0 = (RuleCall)cExpressionAssignment_3.eContents().get(0);
		
		//Variable:
		//	'var' name=ID '=' expression=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//'var' name=ID '=' expression=Expression
		public Group getGroup() { return cGroup; }
		
		//'var'
		public Keyword getVarKeyword_0() { return cVarKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_3() { return cExpressionAssignment_3; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_3_0() { return cExpressionExpressionParserRuleCall_3_0; }
	}
	public class VariableAssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.VariableAssignment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVariableNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVariableNameIDTerminalRuleCall_0_0 = (RuleCall)cVariableNameAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionExpressionParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		
		//VariableAssignment:
		//	variableName=ID '=' expression=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//variableName=ID '=' expression=Expression
		public Group getGroup() { return cGroup; }
		
		//variableName=ID
		public Assignment getVariableNameAssignment_0() { return cVariableNameAssignment_0; }
		
		//ID
		public RuleCall getVariableNameIDTerminalRuleCall_0_0() { return cVariableNameIDTerminalRuleCall_0_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_0() { return cExpressionExpressionParserRuleCall_2_0; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Expression");
		private final RuleCall cOrParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Expression:
		//	Or;
		@Override public ParserRule getRule() { return rule; }
		
		//Or
		public RuleCall getOrParserRuleCall() { return cOrParserRuleCall; }
	}
	public class OrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Or");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cOrKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAndParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Or Expression:
		//	And ({Or.left=current} 'or' right=And)*
		@Override public ParserRule getRule() { return rule; }
		
		//And ({Or.left=current} 'or' right=And)*
		public Group getGroup() { return cGroup; }
		
		//And
		public RuleCall getAndParserRuleCall_0() { return cAndParserRuleCall_0; }
		
		//({Or.left=current} 'or' right=And)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Or.left=current}
		public Action getOrLeftAction_1_0() { return cOrLeftAction_1_0; }
		
		//'or'
		public Keyword getOrKeyword_1_1() { return cOrKeyword_1_1; }
		
		//right=And
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//And
		public RuleCall getRightAndParserRuleCall_1_2_0() { return cRightAndParserRuleCall_1_2_0; }
	}
	public class AndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.And");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cComparisonParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAndKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightComparisonParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//And Expression:
		//	Comparison ({And.left=current} 'and' right=Comparison)*
		@Override public ParserRule getRule() { return rule; }
		
		//Comparison ({And.left=current} 'and' right=Comparison)*
		public Group getGroup() { return cGroup; }
		
		//Comparison
		public RuleCall getComparisonParserRuleCall_0() { return cComparisonParserRuleCall_0; }
		
		//({And.left=current} 'and' right=Comparison)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{And.left=current}
		public Action getAndLeftAction_1_0() { return cAndLeftAction_1_0; }
		
		//'and'
		public Keyword getAndKeyword_1_1() { return cAndKeyword_1_1; }
		
		//right=Comparison
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Comparison
		public RuleCall getRightComparisonParserRuleCall_1_2_0() { return cRightComparisonParserRuleCall_1_2_0; }
	}
	public class PlusElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Plus");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMinusParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cPlusLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightMinusParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Plus Expression:
		//	Minus ({Plus.left=current} '+' right=Minus)*
		@Override public ParserRule getRule() { return rule; }
		
		//Minus ({Plus.left=current} '+' right=Minus)*
		public Group getGroup() { return cGroup; }
		
		//Minus
		public RuleCall getMinusParserRuleCall_0() { return cMinusParserRuleCall_0; }
		
		//({Plus.left=current} '+' right=Minus)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Plus.left=current}
		public Action getPlusLeftAction_1_0() { return cPlusLeftAction_1_0; }
		
		//'+'
		public Keyword getPlusSignKeyword_1_1() { return cPlusSignKeyword_1_1; }
		
		//right=Minus
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Minus
		public RuleCall getRightMinusParserRuleCall_1_2_0() { return cRightMinusParserRuleCall_1_2_0; }
	}
	public class MinusElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Minus");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplyParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMinusLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightMultiplyParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Minus Expression:
		//	Multiply ({Minus.left=current} '-' right=Multiply)*
		@Override public ParserRule getRule() { return rule; }
		
		//Multiply ({Minus.left=current} '-' right=Multiply)*
		public Group getGroup() { return cGroup; }
		
		//Multiply
		public RuleCall getMultiplyParserRuleCall_0() { return cMultiplyParserRuleCall_0; }
		
		//({Minus.left=current} '-' right=Multiply)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Minus.left=current}
		public Action getMinusLeftAction_1_0() { return cMinusLeftAction_1_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_1_1() { return cHyphenMinusKeyword_1_1; }
		
		//right=Multiply
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Multiply
		public RuleCall getRightMultiplyParserRuleCall_1_2_0() { return cRightMultiplyParserRuleCall_1_2_0; }
	}
	public class MultiplyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Multiply");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cDivideParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMultiplyLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAsteriskKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightDivideParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Multiply Expression:
		//	Divide ({Multiply.left=current} '*' right=Divide)*
		@Override public ParserRule getRule() { return rule; }
		
		//Divide ({Multiply.left=current} '*' right=Divide)*
		public Group getGroup() { return cGroup; }
		
		//Divide
		public RuleCall getDivideParserRuleCall_0() { return cDivideParserRuleCall_0; }
		
		//({Multiply.left=current} '*' right=Divide)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Multiply.left=current}
		public Action getMultiplyLeftAction_1_0() { return cMultiplyLeftAction_1_0; }
		
		//'*'
		public Keyword getAsteriskKeyword_1_1() { return cAsteriskKeyword_1_1; }
		
		//right=Divide
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Divide
		public RuleCall getRightDivideParserRuleCall_1_2_0() { return cRightDivideParserRuleCall_1_2_0; }
	}
	public class DivideElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Divide");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cDivideLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cSolidusKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPrimaryExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Divide Expression:
		//	PrimaryExpression ({Divide.left=current} '/' right=PrimaryExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//PrimaryExpression ({Divide.left=current} '/' right=PrimaryExpression)*
		public Group getGroup() { return cGroup; }
		
		//PrimaryExpression
		public RuleCall getPrimaryExpressionParserRuleCall_0() { return cPrimaryExpressionParserRuleCall_0; }
		
		//({Divide.left=current} '/' right=PrimaryExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Divide.left=current}
		public Action getDivideLeftAction_1_0() { return cDivideLeftAction_1_0; }
		
		//'/'
		public Keyword getSolidusKeyword_1_1() { return cSolidusKeyword_1_1; }
		
		//right=PrimaryExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//PrimaryExpression
		public RuleCall getRightPrimaryExpressionParserRuleCall_1_2_0() { return cRightPrimaryExpressionParserRuleCall_1_2_0; }
	}
	public class ComparisonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.Comparison");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPlusParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Keyword cLessThanSignKeyword_1_0_0_0 = (Keyword)cGroup_1_0_0.eContents().get(0);
		private final Action cLessThanLeftAction_1_0_0_1 = (Action)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Keyword cEqualsSignKeyword_1_0_1_0 = (Keyword)cGroup_1_0_1.eContents().get(0);
		private final Action cEqualLeftAction_1_0_1_1 = (Action)cGroup_1_0_1.eContents().get(1);
		private final Group cGroup_1_0_2 = (Group)cAlternatives_1_0.eContents().get(2);
		private final Keyword cGreaterThanSignKeyword_1_0_2_0 = (Keyword)cGroup_1_0_2.eContents().get(0);
		private final Action cGreaterThanLeftAction_1_0_2_1 = (Action)cGroup_1_0_2.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightPlusParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//Comparison Expression:
		//	Plus (('<' {LessThan.left=current} | '=' {Equal.left=current} | '>' {GreaterThan.left=current}) right=Plus)*
		@Override public ParserRule getRule() { return rule; }
		
		//Plus (('<' {LessThan.left=current} | '=' {Equal.left=current} | '>' {GreaterThan.left=current}) right=Plus)*
		public Group getGroup() { return cGroup; }
		
		//Plus
		public RuleCall getPlusParserRuleCall_0() { return cPlusParserRuleCall_0; }
		
		//(('<' {LessThan.left=current} | '=' {Equal.left=current} | '>' {GreaterThan.left=current}) right=Plus)*
		public Group getGroup_1() { return cGroup_1; }
		
		//('<' {LessThan.left=current} | '=' {Equal.left=current} | '>' {GreaterThan.left=current})
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }
		
		//'<' {LessThan.left=current}
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//'<'
		public Keyword getLessThanSignKeyword_1_0_0_0() { return cLessThanSignKeyword_1_0_0_0; }
		
		//{LessThan.left=current}
		public Action getLessThanLeftAction_1_0_0_1() { return cLessThanLeftAction_1_0_0_1; }
		
		//'=' {Equal.left=current}
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }
		
		//'='
		public Keyword getEqualsSignKeyword_1_0_1_0() { return cEqualsSignKeyword_1_0_1_0; }
		
		//{Equal.left=current}
		public Action getEqualLeftAction_1_0_1_1() { return cEqualLeftAction_1_0_1_1; }
		
		//'>' {GreaterThan.left=current}
		public Group getGroup_1_0_2() { return cGroup_1_0_2; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword_1_0_2_0() { return cGreaterThanSignKeyword_1_0_2_0; }
		
		//{GreaterThan.left=current}
		public Action getGreaterThanLeftAction_1_0_2_1() { return cGreaterThanLeftAction_1_0_2_1; }
		
		//right=Plus
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//Plus
		public RuleCall getRightPlusParserRuleCall_1_1_0() { return cRightPlusParserRuleCall_1_1_0; }
	}
	public class PrimaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.PrimaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cNotAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cNotKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cExpressionPrimaryExpressionParserRuleCall_1_2_0 = (RuleCall)cExpressionAssignment_1_2.eContents().get(0);
		private final RuleCall cAtomicExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//PrimaryExpression Expression:
		//	'(' Expression ')' | {Not} 'not' expression=PrimaryExpression | AtomicExpression
		@Override public ParserRule getRule() { return rule; }
		
		//'(' Expression ')' | {Not} 'not' expression=PrimaryExpression | AtomicExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'(' Expression ')'
		public Group getGroup_0() { return cGroup_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_0_1() { return cExpressionParserRuleCall_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }
		
		//{Not} 'not' expression=PrimaryExpression
		public Group getGroup_1() { return cGroup_1; }
		
		//{Not}
		public Action getNotAction_1_0() { return cNotAction_1_0; }
		
		//'not'
		public Keyword getNotKeyword_1_1() { return cNotKeyword_1_1; }
		
		//expression=PrimaryExpression
		public Assignment getExpressionAssignment_1_2() { return cExpressionAssignment_1_2; }
		
		//PrimaryExpression
		public RuleCall getExpressionPrimaryExpressionParserRuleCall_1_2_0() { return cExpressionPrimaryExpressionParserRuleCall_1_2_0; }
		
		//AtomicExpression
		public RuleCall getAtomicExpressionParserRuleCall_2() { return cAtomicExpressionParserRuleCall_2; }
	}
	public class AtomicExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.AtomicExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cBooleanLiteralAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Alternatives cAlternatives_0_1 = (Alternatives)cGroup_0.eContents().get(1);
		private final Assignment cValueAssignment_0_1_0 = (Assignment)cAlternatives_0_1.eContents().get(0);
		private final Keyword cValueTrueKeyword_0_1_0_0 = (Keyword)cValueAssignment_0_1_0.eContents().get(0);
		private final Keyword cFalseKeyword_0_1_1 = (Keyword)cAlternatives_0_1.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cNumericLiteralAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValueDECIMALTerminalRuleCall_1_1_0 = (RuleCall)cValueAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cStringLiteralAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Assignment cValueAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_2_1_0 = (RuleCall)cValueAssignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cVariableRefAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final Assignment cVariableNameAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cVariableNameIDTerminalRuleCall_3_1_0 = (RuleCall)cVariableNameAssignment_3_1.eContents().get(0);
		
		//AtomicExpression Expression:
		//	{BooleanLiteral} (value?='true' | 'false') | {NumericLiteral} value=DECIMAL | {StringLiteral} value=STRING |
		//	{VariableRef} variableName=ID
		@Override public ParserRule getRule() { return rule; }
		
		//{BooleanLiteral} (value?='true' | 'false') | {NumericLiteral} value=DECIMAL | {StringLiteral} value=STRING |
		//{VariableRef} variableName=ID
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{BooleanLiteral} (value?='true' | 'false')
		public Group getGroup_0() { return cGroup_0; }
		
		//{BooleanLiteral}
		public Action getBooleanLiteralAction_0_0() { return cBooleanLiteralAction_0_0; }
		
		//(value?='true' | 'false')
		public Alternatives getAlternatives_0_1() { return cAlternatives_0_1; }
		
		//value?='true'
		public Assignment getValueAssignment_0_1_0() { return cValueAssignment_0_1_0; }
		
		//'true'
		public Keyword getValueTrueKeyword_0_1_0_0() { return cValueTrueKeyword_0_1_0_0; }
		
		//'false'
		public Keyword getFalseKeyword_0_1_1() { return cFalseKeyword_0_1_1; }
		
		//{NumericLiteral} value=DECIMAL
		public Group getGroup_1() { return cGroup_1; }
		
		//{NumericLiteral}
		public Action getNumericLiteralAction_1_0() { return cNumericLiteralAction_1_0; }
		
		//value=DECIMAL
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }
		
		//DECIMAL
		public RuleCall getValueDECIMALTerminalRuleCall_1_1_0() { return cValueDECIMALTerminalRuleCall_1_1_0; }
		
		//{StringLiteral} value=STRING
		public Group getGroup_2() { return cGroup_2; }
		
		//{StringLiteral}
		public Action getStringLiteralAction_2_0() { return cStringLiteralAction_2_0; }
		
		//value=STRING
		public Assignment getValueAssignment_2_1() { return cValueAssignment_2_1; }
		
		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_2_1_0() { return cValueSTRINGTerminalRuleCall_2_1_0; }
		
		//{VariableRef} variableName=ID
		public Group getGroup_3() { return cGroup_3; }
		
		//{VariableRef}
		public Action getVariableRefAction_3_0() { return cVariableRefAction_3_0; }
		
		//variableName=ID
		public Assignment getVariableNameAssignment_3_1() { return cVariableNameAssignment_3_1; }
		
		//ID
		public RuleCall getVariableNameIDTerminalRuleCall_3_1_0() { return cVariableNameIDTerminalRuleCall_3_1_0; }
	}
	
	public class EventTypeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.EventType");
		private final EnumLiteralDeclaration cGAME_STARTEDEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cGAME_STARTEDGAME_STARTEDKeyword_0 = (Keyword)cGAME_STARTEDEnumLiteralDeclaration.eContents().get(0);
		
		//enum EventType:
		//	GAME_STARTED;
		public EnumRule getRule() { return rule; }
		
		//GAME_STARTED
		public EnumLiteralDeclaration getGAME_STARTEDEnumLiteralDeclaration() { return cGAME_STARTEDEnumLiteralDeclaration; }
		
		//"GAME_STARTED"
		public Keyword getGAME_STARTEDGAME_STARTEDKeyword_0() { return cGAME_STARTEDGAME_STARTEDKeyword_0; }
	}
	
	private final GameElements pGame;
	private final ActorElements pActor;
	private final EntityElements pEntity;
	private final EventHandlerElements pEventHandler;
	private final EventTypeElements eEventType;
	private final WhileLoopElements pWhileLoop;
	private final IfElements pIf;
	private final ForeverLoopElements pForeverLoop;
	private final StatementElements pStatement;
	private final ControlStatementElements pControlStatement;
	private final YieldElements pYield;
	private final VariableElements pVariable;
	private final VariableAssignmentElements pVariableAssignment;
	private final ExpressionElements pExpression;
	private final OrElements pOr;
	private final AndElements pAnd;
	private final PlusElements pPlus;
	private final MinusElements pMinus;
	private final MultiplyElements pMultiply;
	private final DivideElements pDivide;
	private final ComparisonElements pComparison;
	private final PrimaryExpressionElements pPrimaryExpression;
	private final AtomicExpressionElements pAtomicExpression;
	private final TerminalRule tBEGIN;
	private final TerminalRule tEND;
	private final TerminalRule tDECIMAL;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public KlangGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pGame = new GameElements();
		this.pActor = new ActorElements();
		this.pEntity = new EntityElements();
		this.pEventHandler = new EventHandlerElements();
		this.eEventType = new EventTypeElements();
		this.pWhileLoop = new WhileLoopElements();
		this.pIf = new IfElements();
		this.pForeverLoop = new ForeverLoopElements();
		this.pStatement = new StatementElements();
		this.pControlStatement = new ControlStatementElements();
		this.pYield = new YieldElements();
		this.pVariable = new VariableElements();
		this.pVariableAssignment = new VariableAssignmentElements();
		this.pExpression = new ExpressionElements();
		this.pOr = new OrElements();
		this.pAnd = new AndElements();
		this.pPlus = new PlusElements();
		this.pMinus = new MinusElements();
		this.pMultiply = new MultiplyElements();
		this.pDivide = new DivideElements();
		this.pComparison = new ComparisonElements();
		this.pPrimaryExpression = new PrimaryExpressionElements();
		this.pAtomicExpression = new AtomicExpressionElements();
		this.tBEGIN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.BEGIN");
		this.tEND = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.END");
		this.tDECIMAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.kaurel.klang.xtext.Klang.DECIMAL");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("com.kaurel.klang.xtext.Klang".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Game:
	//	{Game} variableDeclarations+=Variable*
	//	actorDefs+=Actor*;
	public GameElements getGameAccess() {
		return pGame;
	}
	
	public ParserRule getGameRule() {
		return getGameAccess().getRule();
	}
	
	//Actor:
	//	{Actor} entity=Entity
	//	BEGIN
	//	variableDeclarations+=Variable*
	//	eventHandlers+=EventHandler*
	//	END;
	public ActorElements getActorAccess() {
		return pActor;
	}
	
	public ParserRule getActorRule() {
		return getActorAccess().getRule();
	}
	
	//Entity:
	//	'sprite' {SpriteEntity} name=ID | 'scene' {SceneEntity};
	public EntityElements getEntityAccess() {
		return pEntity;
	}
	
	public ParserRule getEntityRule() {
		return getEntityAccess().getRule();
	}
	
	//EventHandler:
	//	'when'
	//	eventType=EventType
	//	BEGIN
	//	statements+=Statement*
	//	END;
	public EventHandlerElements getEventHandlerAccess() {
		return pEventHandler;
	}
	
	public ParserRule getEventHandlerRule() {
		return getEventHandlerAccess().getRule();
	}
	
	//enum EventType:
	//	GAME_STARTED;
	public EventTypeElements getEventTypeAccess() {
		return eEventType;
	}
	
	public EnumRule getEventTypeRule() {
		return getEventTypeAccess().getRule();
	}
	
	//WhileLoop:
	//	{WhileLoop}
	//	'while' predicate=Expression
	//	BEGIN
	//	loopBlock+=Statement*
	//	END;
	public WhileLoopElements getWhileLoopAccess() {
		return pWhileLoop;
	}
	
	public ParserRule getWhileLoopRule() {
		return getWhileLoopAccess().getRule();
	}
	
	//If:
	//	{If}
	//	'if' predicate=Expression
	//	BEGIN
	//	ifBlock+=Statement*
	//	END;
	public IfElements getIfAccess() {
		return pIf;
	}
	
	public ParserRule getIfRule() {
		return getIfAccess().getRule();
	}
	
	//ForeverLoop:
	//	{ForeverLoop}
	//	'forever'
	//	BEGIN
	//	loopStatements+=Statement*
	//	END;
	public ForeverLoopElements getForeverLoopAccess() {
		return pForeverLoop;
	}
	
	public ParserRule getForeverLoopRule() {
		return getForeverLoopAccess().getRule();
	}
	
	//Statement:
	//	ControlStatement | Variable | VariableAssignment;
	public StatementElements getStatementAccess() {
		return pStatement;
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}
	
	//ControlStatement:
	//	ForeverLoop | WhileLoop | Yield | If;
	public ControlStatementElements getControlStatementAccess() {
		return pControlStatement;
	}
	
	public ParserRule getControlStatementRule() {
		return getControlStatementAccess().getRule();
	}
	
	//Yield:
	//	{Yield}
	//	'yield';
	public YieldElements getYieldAccess() {
		return pYield;
	}
	
	public ParserRule getYieldRule() {
		return getYieldAccess().getRule();
	}
	
	//Variable:
	//	'var' name=ID '=' expression=Expression;
	public VariableElements getVariableAccess() {
		return pVariable;
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}
	
	//VariableAssignment:
	//	variableName=ID '=' expression=Expression;
	public VariableAssignmentElements getVariableAssignmentAccess() {
		return pVariableAssignment;
	}
	
	public ParserRule getVariableAssignmentRule() {
		return getVariableAssignmentAccess().getRule();
	}
	
	//Expression:
	//	Or;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//Or Expression:
	//	And ({Or.left=current} 'or' right=And)*
	public OrElements getOrAccess() {
		return pOr;
	}
	
	public ParserRule getOrRule() {
		return getOrAccess().getRule();
	}
	
	//And Expression:
	//	Comparison ({And.left=current} 'and' right=Comparison)*
	public AndElements getAndAccess() {
		return pAnd;
	}
	
	public ParserRule getAndRule() {
		return getAndAccess().getRule();
	}
	
	//Plus Expression:
	//	Minus ({Plus.left=current} '+' right=Minus)*
	public PlusElements getPlusAccess() {
		return pPlus;
	}
	
	public ParserRule getPlusRule() {
		return getPlusAccess().getRule();
	}
	
	//Minus Expression:
	//	Multiply ({Minus.left=current} '-' right=Multiply)*
	public MinusElements getMinusAccess() {
		return pMinus;
	}
	
	public ParserRule getMinusRule() {
		return getMinusAccess().getRule();
	}
	
	//Multiply Expression:
	//	Divide ({Multiply.left=current} '*' right=Divide)*
	public MultiplyElements getMultiplyAccess() {
		return pMultiply;
	}
	
	public ParserRule getMultiplyRule() {
		return getMultiplyAccess().getRule();
	}
	
	//Divide Expression:
	//	PrimaryExpression ({Divide.left=current} '/' right=PrimaryExpression)*
	public DivideElements getDivideAccess() {
		return pDivide;
	}
	
	public ParserRule getDivideRule() {
		return getDivideAccess().getRule();
	}
	
	//Comparison Expression:
	//	Plus (('<' {LessThan.left=current} | '=' {Equal.left=current} | '>' {GreaterThan.left=current}) right=Plus)*
	public ComparisonElements getComparisonAccess() {
		return pComparison;
	}
	
	public ParserRule getComparisonRule() {
		return getComparisonAccess().getRule();
	}
	
	//PrimaryExpression Expression:
	//	'(' Expression ')' | {Not} 'not' expression=PrimaryExpression | AtomicExpression
	public PrimaryExpressionElements getPrimaryExpressionAccess() {
		return pPrimaryExpression;
	}
	
	public ParserRule getPrimaryExpressionRule() {
		return getPrimaryExpressionAccess().getRule();
	}
	
	//AtomicExpression Expression:
	//	{BooleanLiteral} (value?='true' | 'false') | {NumericLiteral} value=DECIMAL | {StringLiteral} value=STRING |
	//	{VariableRef} variableName=ID
	public AtomicExpressionElements getAtomicExpressionAccess() {
		return pAtomicExpression;
	}
	
	public ParserRule getAtomicExpressionRule() {
		return getAtomicExpressionAccess().getRule();
	}
	
	//terminal BEGIN:
	//	'synthetic:BEGIN';
	public TerminalRule getBEGINRule() {
		return tBEGIN;
	}
	
	//terminal END:
	//	'synthetic:END';
	public TerminalRule getENDRule() {
		return tEND;
	}
	
	//terminal DECIMAL returns ecore::EDouble:
	//	INT ('.' INT)?;
	public TerminalRule getDECIMALRule() {
		return tDECIMAL;
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/ *'->'* /';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
