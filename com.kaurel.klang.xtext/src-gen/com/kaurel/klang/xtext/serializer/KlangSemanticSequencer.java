/*
 * generated by Xtext 2.10.0-SNAPSHOT
 */
package com.kaurel.klang.xtext.serializer;

import com.google.inject.Inject;
import com.kaurel.klang.xtext.services.KlangGrammarAccess;
import java.util.Set;
import klang.ClickEvent;
import klang.CollisionEvent;
import klang.EventHandler;
import klang.GameStartEvent;
import klang.KeyPressEvent;
import klang.KlangPackage;
import klang.MessageReceivedEvent;
import klang.Program;
import klang.SceneActor;
import klang.SpriteActor;
import klang.VariableDeclaration;
import klangexpr.And;
import klangexpr.BooleanLiteral;
import klangexpr.Divide;
import klangexpr.DoubleLiteral;
import klangexpr.Equal;
import klangexpr.ForeverLoop;
import klangexpr.FunctionCall;
import klangexpr.GreaterThan;
import klangexpr.GreaterThanOrEqual;
import klangexpr.If;
import klangexpr.IntegerLiteral;
import klangexpr.KlangexprPackage;
import klangexpr.LessThan;
import klangexpr.LessThanOrEqual;
import klangexpr.Minus;
import klangexpr.Multiply;
import klangexpr.Not;
import klangexpr.Or;
import klangexpr.Plus;
import klangexpr.SendMessage;
import klangexpr.Sleep;
import klangexpr.StringLiteral;
import klangexpr.ToDouble;
import klangexpr.ToInt;
import klangexpr.UnaryMinus;
import klangexpr.VariableAssignment;
import klangexpr.VariableReference;
import klangexpr.WhileLoop;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class KlangSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private KlangGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == KlangPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case KlangPackage.CLICK_EVENT:
				sequence_ClickEvent(context, (ClickEvent) semanticObject); 
				return; 
			case KlangPackage.COLLISION_EVENT:
				sequence_CollisionEvent(context, (CollisionEvent) semanticObject); 
				return; 
			case KlangPackage.EVENT_HANDLER:
				sequence_EventHandler(context, (EventHandler) semanticObject); 
				return; 
			case KlangPackage.GAME_START_EVENT:
				sequence_GameStartEvent(context, (GameStartEvent) semanticObject); 
				return; 
			case KlangPackage.KEY_PRESS_EVENT:
				sequence_KeyPressedEvent(context, (KeyPressEvent) semanticObject); 
				return; 
			case KlangPackage.MESSAGE_RECEIVED_EVENT:
				sequence_MessageReceivedEvent(context, (MessageReceivedEvent) semanticObject); 
				return; 
			case KlangPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case KlangPackage.SCENE_ACTOR:
				sequence_SceneActor(context, (SceneActor) semanticObject); 
				return; 
			case KlangPackage.SPRITE_ACTOR:
				sequence_SpriteActor(context, (SpriteActor) semanticObject); 
				return; 
			case KlangPackage.VARIABLE_DECLARATION:
				sequence_VariableDeclaration(context, (VariableDeclaration) semanticObject); 
				return; 
			}
		else if (epackage == KlangexprPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case KlangexprPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case KlangexprPackage.BOOLEAN_LITERAL:
				sequence_AtomicExpression(context, (BooleanLiteral) semanticObject); 
				return; 
			case KlangexprPackage.DIVIDE:
				sequence_Divide(context, (Divide) semanticObject); 
				return; 
			case KlangexprPackage.DOUBLE_LITERAL:
				sequence_AtomicExpression(context, (DoubleLiteral) semanticObject); 
				return; 
			case KlangexprPackage.EQUAL:
				sequence_Comparison(context, (Equal) semanticObject); 
				return; 
			case KlangexprPackage.FOREVER_LOOP:
				sequence_ForeverLoop(context, (ForeverLoop) semanticObject); 
				return; 
			case KlangexprPackage.FUNCTION_CALL:
				sequence_FunctionCall(context, (FunctionCall) semanticObject); 
				return; 
			case KlangexprPackage.GREATER_THAN:
				sequence_Comparison(context, (GreaterThan) semanticObject); 
				return; 
			case KlangexprPackage.GREATER_THAN_OR_EQUAL:
				sequence_Comparison(context, (GreaterThanOrEqual) semanticObject); 
				return; 
			case KlangexprPackage.IF:
				sequence_If(context, (If) semanticObject); 
				return; 
			case KlangexprPackage.INTEGER_LITERAL:
				sequence_AtomicExpression(context, (IntegerLiteral) semanticObject); 
				return; 
			case KlangexprPackage.LESS_THAN:
				sequence_Comparison(context, (LessThan) semanticObject); 
				return; 
			case KlangexprPackage.LESS_THAN_OR_EQUAL:
				sequence_Comparison(context, (LessThanOrEqual) semanticObject); 
				return; 
			case KlangexprPackage.MINUS:
				sequence_Minus(context, (Minus) semanticObject); 
				return; 
			case KlangexprPackage.MULTIPLY:
				sequence_Multiply(context, (Multiply) semanticObject); 
				return; 
			case KlangexprPackage.NOT:
				sequence_PrimaryExpression(context, (Not) semanticObject); 
				return; 
			case KlangexprPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case KlangexprPackage.PLUS:
				sequence_Plus(context, (Plus) semanticObject); 
				return; 
			case KlangexprPackage.SEND_MESSAGE:
				sequence_SendMessage(context, (SendMessage) semanticObject); 
				return; 
			case KlangexprPackage.SLEEP:
				sequence_Sleep(context, (Sleep) semanticObject); 
				return; 
			case KlangexprPackage.STRING_LITERAL:
				sequence_AtomicExpression(context, (StringLiteral) semanticObject); 
				return; 
			case KlangexprPackage.TO_DOUBLE:
				sequence_PrimaryExpression(context, (ToDouble) semanticObject); 
				return; 
			case KlangexprPackage.TO_INT:
				sequence_PrimaryExpression(context, (ToInt) semanticObject); 
				return; 
			case KlangexprPackage.UNARY_MINUS:
				sequence_PrimaryExpression(context, (UnaryMinus) semanticObject); 
				return; 
			case KlangexprPackage.VARIABLE_ASSIGNMENT:
				sequence_VariableAssignment(context, (VariableAssignment) semanticObject); 
				return; 
			case KlangexprPackage.VARIABLE_REFERENCE:
				sequence_AtomicExpression(context, (VariableReference) semanticObject); 
				return; 
			case KlangexprPackage.WHILE_LOOP:
				sequence_WhileLoop(context, (WhileLoop) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expression returns And
	 *     Or returns And
	 *     Or.Or_1_0 returns And
	 *     And returns And
	 *     And.And_1_0 returns And
	 *     Plus returns And
	 *     Plus.Plus_1_0 returns And
	 *     Minus returns And
	 *     Minus.Minus_1_0 returns And
	 *     Multiply returns And
	 *     Multiply.Multiply_1_0 returns And
	 *     Divide returns And
	 *     Divide.Divide_1_0 returns And
	 *     Comparison returns And
	 *     Comparison.LessThan_1_0_0_1 returns And
	 *     Comparison.Equal_1_0_1_1 returns And
	 *     Comparison.GreaterThan_1_0_2_1 returns And
	 *     Comparison.LessThanOrEqual_1_0_3_1 returns And
	 *     Comparison.GreaterThanOrEqual_1_0_4_1 returns And
	 *     PrimaryExpression returns And
	 *
	 * Constraint:
	 *     (left=And_And_1_0 right=Comparison)
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndAccess().getAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndAccess().getRightComparisonParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BooleanLiteral
	 *     Or returns BooleanLiteral
	 *     Or.Or_1_0 returns BooleanLiteral
	 *     And returns BooleanLiteral
	 *     And.And_1_0 returns BooleanLiteral
	 *     Plus returns BooleanLiteral
	 *     Plus.Plus_1_0 returns BooleanLiteral
	 *     Minus returns BooleanLiteral
	 *     Minus.Minus_1_0 returns BooleanLiteral
	 *     Multiply returns BooleanLiteral
	 *     Multiply.Multiply_1_0 returns BooleanLiteral
	 *     Divide returns BooleanLiteral
	 *     Divide.Divide_1_0 returns BooleanLiteral
	 *     Comparison returns BooleanLiteral
	 *     Comparison.LessThan_1_0_0_1 returns BooleanLiteral
	 *     Comparison.Equal_1_0_1_1 returns BooleanLiteral
	 *     Comparison.GreaterThan_1_0_2_1 returns BooleanLiteral
	 *     Comparison.LessThanOrEqual_1_0_3_1 returns BooleanLiteral
	 *     Comparison.GreaterThanOrEqual_1_0_4_1 returns BooleanLiteral
	 *     PrimaryExpression returns BooleanLiteral
	 *     AtomicExpression returns BooleanLiteral
	 *
	 * Constraint:
	 *     value?='true'?
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, BooleanLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns DoubleLiteral
	 *     Or returns DoubleLiteral
	 *     Or.Or_1_0 returns DoubleLiteral
	 *     And returns DoubleLiteral
	 *     And.And_1_0 returns DoubleLiteral
	 *     Plus returns DoubleLiteral
	 *     Plus.Plus_1_0 returns DoubleLiteral
	 *     Minus returns DoubleLiteral
	 *     Minus.Minus_1_0 returns DoubleLiteral
	 *     Multiply returns DoubleLiteral
	 *     Multiply.Multiply_1_0 returns DoubleLiteral
	 *     Divide returns DoubleLiteral
	 *     Divide.Divide_1_0 returns DoubleLiteral
	 *     Comparison returns DoubleLiteral
	 *     Comparison.LessThan_1_0_0_1 returns DoubleLiteral
	 *     Comparison.Equal_1_0_1_1 returns DoubleLiteral
	 *     Comparison.GreaterThan_1_0_2_1 returns DoubleLiteral
	 *     Comparison.LessThanOrEqual_1_0_3_1 returns DoubleLiteral
	 *     Comparison.GreaterThanOrEqual_1_0_4_1 returns DoubleLiteral
	 *     PrimaryExpression returns DoubleLiteral
	 *     AtomicExpression returns DoubleLiteral
	 *
	 * Constraint:
	 *     value=DECIMAL
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, DoubleLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangexprPackage.Literals.DOUBLE_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangexprPackage.Literals.DOUBLE_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getValueDECIMALParserRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IntegerLiteral
	 *     Or returns IntegerLiteral
	 *     Or.Or_1_0 returns IntegerLiteral
	 *     And returns IntegerLiteral
	 *     And.And_1_0 returns IntegerLiteral
	 *     Plus returns IntegerLiteral
	 *     Plus.Plus_1_0 returns IntegerLiteral
	 *     Minus returns IntegerLiteral
	 *     Minus.Minus_1_0 returns IntegerLiteral
	 *     Multiply returns IntegerLiteral
	 *     Multiply.Multiply_1_0 returns IntegerLiteral
	 *     Divide returns IntegerLiteral
	 *     Divide.Divide_1_0 returns IntegerLiteral
	 *     Comparison returns IntegerLiteral
	 *     Comparison.LessThan_1_0_0_1 returns IntegerLiteral
	 *     Comparison.Equal_1_0_1_1 returns IntegerLiteral
	 *     Comparison.GreaterThan_1_0_2_1 returns IntegerLiteral
	 *     Comparison.LessThanOrEqual_1_0_3_1 returns IntegerLiteral
	 *     Comparison.GreaterThanOrEqual_1_0_4_1 returns IntegerLiteral
	 *     PrimaryExpression returns IntegerLiteral
	 *     AtomicExpression returns IntegerLiteral
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, IntegerLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangexprPackage.Literals.INTEGER_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangexprPackage.Literals.INTEGER_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getValueINTTerminalRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns StringLiteral
	 *     Or returns StringLiteral
	 *     Or.Or_1_0 returns StringLiteral
	 *     And returns StringLiteral
	 *     And.And_1_0 returns StringLiteral
	 *     Plus returns StringLiteral
	 *     Plus.Plus_1_0 returns StringLiteral
	 *     Minus returns StringLiteral
	 *     Minus.Minus_1_0 returns StringLiteral
	 *     Multiply returns StringLiteral
	 *     Multiply.Multiply_1_0 returns StringLiteral
	 *     Divide returns StringLiteral
	 *     Divide.Divide_1_0 returns StringLiteral
	 *     Comparison returns StringLiteral
	 *     Comparison.LessThan_1_0_0_1 returns StringLiteral
	 *     Comparison.Equal_1_0_1_1 returns StringLiteral
	 *     Comparison.GreaterThan_1_0_2_1 returns StringLiteral
	 *     Comparison.LessThanOrEqual_1_0_3_1 returns StringLiteral
	 *     Comparison.GreaterThanOrEqual_1_0_4_1 returns StringLiteral
	 *     PrimaryExpression returns StringLiteral
	 *     AtomicExpression returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangexprPackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangexprPackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getValueSTRINGTerminalRuleCall_3_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns VariableReference
	 *     Or returns VariableReference
	 *     Or.Or_1_0 returns VariableReference
	 *     And returns VariableReference
	 *     And.And_1_0 returns VariableReference
	 *     Plus returns VariableReference
	 *     Plus.Plus_1_0 returns VariableReference
	 *     Minus returns VariableReference
	 *     Minus.Minus_1_0 returns VariableReference
	 *     Multiply returns VariableReference
	 *     Multiply.Multiply_1_0 returns VariableReference
	 *     Divide returns VariableReference
	 *     Divide.Divide_1_0 returns VariableReference
	 *     Comparison returns VariableReference
	 *     Comparison.LessThan_1_0_0_1 returns VariableReference
	 *     Comparison.Equal_1_0_1_1 returns VariableReference
	 *     Comparison.GreaterThan_1_0_2_1 returns VariableReference
	 *     Comparison.LessThanOrEqual_1_0_3_1 returns VariableReference
	 *     Comparison.GreaterThanOrEqual_1_0_4_1 returns VariableReference
	 *     PrimaryExpression returns VariableReference
	 *     AtomicExpression returns VariableReference
	 *
	 * Constraint:
	 *     variableName=ID
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, VariableReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangexprPackage.Literals.VARIABLE_REFERENCE__VARIABLE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangexprPackage.Literals.VARIABLE_REFERENCE__VARIABLE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getVariableNameIDTerminalRuleCall_4_1_0(), semanticObject.getVariableName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Event returns ClickEvent
	 *     ClickEvent returns ClickEvent
	 *
	 * Constraint:
	 *     {ClickEvent}
	 */
	protected void sequence_ClickEvent(ISerializationContext context, ClickEvent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Event returns CollisionEvent
	 *     CollisionEvent returns CollisionEvent
	 *
	 * Constraint:
	 *     target=[SpriteActor|ID]
	 */
	protected void sequence_CollisionEvent(ISerializationContext context, CollisionEvent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.COLLISION_EVENT__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.COLLISION_EVENT__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCollisionEventAccess().getTargetSpriteActorIDTerminalRuleCall_3_0_1(), semanticObject.getTarget());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Equal
	 *     Or returns Equal
	 *     Or.Or_1_0 returns Equal
	 *     And returns Equal
	 *     And.And_1_0 returns Equal
	 *     Plus returns Equal
	 *     Plus.Plus_1_0 returns Equal
	 *     Minus returns Equal
	 *     Minus.Minus_1_0 returns Equal
	 *     Multiply returns Equal
	 *     Multiply.Multiply_1_0 returns Equal
	 *     Divide returns Equal
	 *     Divide.Divide_1_0 returns Equal
	 *     Comparison returns Equal
	 *     Comparison.LessThan_1_0_0_1 returns Equal
	 *     Comparison.Equal_1_0_1_1 returns Equal
	 *     Comparison.GreaterThan_1_0_2_1 returns Equal
	 *     Comparison.LessThanOrEqual_1_0_3_1 returns Equal
	 *     Comparison.GreaterThanOrEqual_1_0_4_1 returns Equal
	 *     PrimaryExpression returns Equal
	 *
	 * Constraint:
	 *     (left=Comparison_Equal_1_0_1_1 right=Plus)
	 */
	protected void sequence_Comparison(ISerializationContext context, Equal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getEqualLeftAction_1_0_1_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonAccess().getRightPlusParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns GreaterThan
	 *     Or returns GreaterThan
	 *     Or.Or_1_0 returns GreaterThan
	 *     And returns GreaterThan
	 *     And.And_1_0 returns GreaterThan
	 *     Plus returns GreaterThan
	 *     Plus.Plus_1_0 returns GreaterThan
	 *     Minus returns GreaterThan
	 *     Minus.Minus_1_0 returns GreaterThan
	 *     Multiply returns GreaterThan
	 *     Multiply.Multiply_1_0 returns GreaterThan
	 *     Divide returns GreaterThan
	 *     Divide.Divide_1_0 returns GreaterThan
	 *     Comparison returns GreaterThan
	 *     Comparison.LessThan_1_0_0_1 returns GreaterThan
	 *     Comparison.Equal_1_0_1_1 returns GreaterThan
	 *     Comparison.GreaterThan_1_0_2_1 returns GreaterThan
	 *     Comparison.LessThanOrEqual_1_0_3_1 returns GreaterThan
	 *     Comparison.GreaterThanOrEqual_1_0_4_1 returns GreaterThan
	 *     PrimaryExpression returns GreaterThan
	 *
	 * Constraint:
	 *     (left=Comparison_GreaterThan_1_0_2_1 right=Plus)
	 */
	protected void sequence_Comparison(ISerializationContext context, GreaterThan semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getGreaterThanLeftAction_1_0_2_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonAccess().getRightPlusParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns GreaterThanOrEqual
	 *     Or returns GreaterThanOrEqual
	 *     Or.Or_1_0 returns GreaterThanOrEqual
	 *     And returns GreaterThanOrEqual
	 *     And.And_1_0 returns GreaterThanOrEqual
	 *     Plus returns GreaterThanOrEqual
	 *     Plus.Plus_1_0 returns GreaterThanOrEqual
	 *     Minus returns GreaterThanOrEqual
	 *     Minus.Minus_1_0 returns GreaterThanOrEqual
	 *     Multiply returns GreaterThanOrEqual
	 *     Multiply.Multiply_1_0 returns GreaterThanOrEqual
	 *     Divide returns GreaterThanOrEqual
	 *     Divide.Divide_1_0 returns GreaterThanOrEqual
	 *     Comparison returns GreaterThanOrEqual
	 *     Comparison.LessThan_1_0_0_1 returns GreaterThanOrEqual
	 *     Comparison.Equal_1_0_1_1 returns GreaterThanOrEqual
	 *     Comparison.GreaterThan_1_0_2_1 returns GreaterThanOrEqual
	 *     Comparison.LessThanOrEqual_1_0_3_1 returns GreaterThanOrEqual
	 *     Comparison.GreaterThanOrEqual_1_0_4_1 returns GreaterThanOrEqual
	 *     PrimaryExpression returns GreaterThanOrEqual
	 *
	 * Constraint:
	 *     (left=Comparison_GreaterThanOrEqual_1_0_4_1 right=Plus)
	 */
	protected void sequence_Comparison(ISerializationContext context, GreaterThanOrEqual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getGreaterThanOrEqualLeftAction_1_0_4_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonAccess().getRightPlusParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LessThan
	 *     Or returns LessThan
	 *     Or.Or_1_0 returns LessThan
	 *     And returns LessThan
	 *     And.And_1_0 returns LessThan
	 *     Plus returns LessThan
	 *     Plus.Plus_1_0 returns LessThan
	 *     Minus returns LessThan
	 *     Minus.Minus_1_0 returns LessThan
	 *     Multiply returns LessThan
	 *     Multiply.Multiply_1_0 returns LessThan
	 *     Divide returns LessThan
	 *     Divide.Divide_1_0 returns LessThan
	 *     Comparison returns LessThan
	 *     Comparison.LessThan_1_0_0_1 returns LessThan
	 *     Comparison.Equal_1_0_1_1 returns LessThan
	 *     Comparison.GreaterThan_1_0_2_1 returns LessThan
	 *     Comparison.LessThanOrEqual_1_0_3_1 returns LessThan
	 *     Comparison.GreaterThanOrEqual_1_0_4_1 returns LessThan
	 *     PrimaryExpression returns LessThan
	 *
	 * Constraint:
	 *     (left=Comparison_LessThan_1_0_0_1 right=Plus)
	 */
	protected void sequence_Comparison(ISerializationContext context, LessThan semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getLessThanLeftAction_1_0_0_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonAccess().getRightPlusParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LessThanOrEqual
	 *     Or returns LessThanOrEqual
	 *     Or.Or_1_0 returns LessThanOrEqual
	 *     And returns LessThanOrEqual
	 *     And.And_1_0 returns LessThanOrEqual
	 *     Plus returns LessThanOrEqual
	 *     Plus.Plus_1_0 returns LessThanOrEqual
	 *     Minus returns LessThanOrEqual
	 *     Minus.Minus_1_0 returns LessThanOrEqual
	 *     Multiply returns LessThanOrEqual
	 *     Multiply.Multiply_1_0 returns LessThanOrEqual
	 *     Divide returns LessThanOrEqual
	 *     Divide.Divide_1_0 returns LessThanOrEqual
	 *     Comparison returns LessThanOrEqual
	 *     Comparison.LessThan_1_0_0_1 returns LessThanOrEqual
	 *     Comparison.Equal_1_0_1_1 returns LessThanOrEqual
	 *     Comparison.GreaterThan_1_0_2_1 returns LessThanOrEqual
	 *     Comparison.LessThanOrEqual_1_0_3_1 returns LessThanOrEqual
	 *     Comparison.GreaterThanOrEqual_1_0_4_1 returns LessThanOrEqual
	 *     PrimaryExpression returns LessThanOrEqual
	 *
	 * Constraint:
	 *     (left=Comparison_LessThanOrEqual_1_0_3_1 right=Plus)
	 */
	protected void sequence_Comparison(ISerializationContext context, LessThanOrEqual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getLessThanOrEqualLeftAction_1_0_3_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonAccess().getRightPlusParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Divide
	 *     Or returns Divide
	 *     Or.Or_1_0 returns Divide
	 *     And returns Divide
	 *     And.And_1_0 returns Divide
	 *     Plus returns Divide
	 *     Plus.Plus_1_0 returns Divide
	 *     Minus returns Divide
	 *     Minus.Minus_1_0 returns Divide
	 *     Multiply returns Divide
	 *     Multiply.Multiply_1_0 returns Divide
	 *     Divide returns Divide
	 *     Divide.Divide_1_0 returns Divide
	 *     Comparison returns Divide
	 *     Comparison.LessThan_1_0_0_1 returns Divide
	 *     Comparison.Equal_1_0_1_1 returns Divide
	 *     Comparison.GreaterThan_1_0_2_1 returns Divide
	 *     Comparison.LessThanOrEqual_1_0_3_1 returns Divide
	 *     Comparison.GreaterThanOrEqual_1_0_4_1 returns Divide
	 *     PrimaryExpression returns Divide
	 *
	 * Constraint:
	 *     (left=Divide_Divide_1_0 right=PrimaryExpression)
	 */
	protected void sequence_Divide(ISerializationContext context, Divide semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDivideAccess().getDivideLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getDivideAccess().getRightPrimaryExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EventHandler returns EventHandler
	 *
	 * Constraint:
	 *     (referenceEvent=Event statements+=Statement*)
	 */
	protected void sequence_EventHandler(ISerializationContext context, EventHandler semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ForeverLoop
	 *     ForeverLoop returns ForeverLoop
	 *
	 * Constraint:
	 *     statements+=Statement*
	 */
	protected void sequence_ForeverLoop(ISerializationContext context, ForeverLoop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns FunctionCall
	 *     Expression returns FunctionCall
	 *     Or returns FunctionCall
	 *     Or.Or_1_0 returns FunctionCall
	 *     And returns FunctionCall
	 *     And.And_1_0 returns FunctionCall
	 *     Plus returns FunctionCall
	 *     Plus.Plus_1_0 returns FunctionCall
	 *     Minus returns FunctionCall
	 *     Minus.Minus_1_0 returns FunctionCall
	 *     Multiply returns FunctionCall
	 *     Multiply.Multiply_1_0 returns FunctionCall
	 *     Divide returns FunctionCall
	 *     Divide.Divide_1_0 returns FunctionCall
	 *     Comparison returns FunctionCall
	 *     Comparison.LessThan_1_0_0_1 returns FunctionCall
	 *     Comparison.Equal_1_0_1_1 returns FunctionCall
	 *     Comparison.GreaterThan_1_0_2_1 returns FunctionCall
	 *     Comparison.LessThanOrEqual_1_0_3_1 returns FunctionCall
	 *     Comparison.GreaterThanOrEqual_1_0_4_1 returns FunctionCall
	 *     FunctionCall returns FunctionCall
	 *     PrimaryExpression returns FunctionCall
	 *
	 * Constraint:
	 *     (name=ID (parameters+=Expression parameters+=Expression*)?)
	 */
	protected void sequence_FunctionCall(ISerializationContext context, FunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Event returns GameStartEvent
	 *     GameStartEvent returns GameStartEvent
	 *
	 * Constraint:
	 *     {GameStartEvent}
	 */
	protected void sequence_GameStartEvent(ISerializationContext context, GameStartEvent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns If
	 *     If returns If
	 *
	 * Constraint:
	 *     (predicate=Expression ifBlock+=Statement* elseBlock+=Statement*)
	 */
	protected void sequence_If(ISerializationContext context, If semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Event returns KeyPressEvent
	 *     KeyPressedEvent returns KeyPressEvent
	 *
	 * Constraint:
	 *     key=Keys
	 */
	protected void sequence_KeyPressedEvent(ISerializationContext context, KeyPressEvent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.KEY_PRESS_EVENT__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.KEY_PRESS_EVENT__KEY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getKeyPressedEventAccess().getKeyKeysEnumRuleCall_1_0(), semanticObject.getKey());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Event returns MessageReceivedEvent
	 *     MessageReceivedEvent returns MessageReceivedEvent
	 *
	 * Constraint:
	 *     name=STRING
	 */
	protected void sequence_MessageReceivedEvent(ISerializationContext context, MessageReceivedEvent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.MESSAGE_RECEIVED_EVENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.MESSAGE_RECEIVED_EVENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMessageReceivedEventAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Minus
	 *     Or returns Minus
	 *     Or.Or_1_0 returns Minus
	 *     And returns Minus
	 *     And.And_1_0 returns Minus
	 *     Plus returns Minus
	 *     Plus.Plus_1_0 returns Minus
	 *     Minus returns Minus
	 *     Minus.Minus_1_0 returns Minus
	 *     Multiply returns Minus
	 *     Multiply.Multiply_1_0 returns Minus
	 *     Divide returns Minus
	 *     Divide.Divide_1_0 returns Minus
	 *     Comparison returns Minus
	 *     Comparison.LessThan_1_0_0_1 returns Minus
	 *     Comparison.Equal_1_0_1_1 returns Minus
	 *     Comparison.GreaterThan_1_0_2_1 returns Minus
	 *     Comparison.LessThanOrEqual_1_0_3_1 returns Minus
	 *     Comparison.GreaterThanOrEqual_1_0_4_1 returns Minus
	 *     PrimaryExpression returns Minus
	 *
	 * Constraint:
	 *     (left=Minus_Minus_1_0 right=Multiply)
	 */
	protected void sequence_Minus(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMinusAccess().getMinusLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMinusAccess().getRightMultiplyParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Multiply
	 *     Or returns Multiply
	 *     Or.Or_1_0 returns Multiply
	 *     And returns Multiply
	 *     And.And_1_0 returns Multiply
	 *     Plus returns Multiply
	 *     Plus.Plus_1_0 returns Multiply
	 *     Minus returns Multiply
	 *     Minus.Minus_1_0 returns Multiply
	 *     Multiply returns Multiply
	 *     Multiply.Multiply_1_0 returns Multiply
	 *     Divide returns Multiply
	 *     Divide.Divide_1_0 returns Multiply
	 *     Comparison returns Multiply
	 *     Comparison.LessThan_1_0_0_1 returns Multiply
	 *     Comparison.Equal_1_0_1_1 returns Multiply
	 *     Comparison.GreaterThan_1_0_2_1 returns Multiply
	 *     Comparison.LessThanOrEqual_1_0_3_1 returns Multiply
	 *     Comparison.GreaterThanOrEqual_1_0_4_1 returns Multiply
	 *     PrimaryExpression returns Multiply
	 *
	 * Constraint:
	 *     (left=Multiply_Multiply_1_0 right=Divide)
	 */
	protected void sequence_Multiply(ISerializationContext context, Multiply semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplyAccess().getMultiplyLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplyAccess().getRightDivideParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Or
	 *     Or returns Or
	 *     Or.Or_1_0 returns Or
	 *     And returns Or
	 *     And.And_1_0 returns Or
	 *     Plus returns Or
	 *     Plus.Plus_1_0 returns Or
	 *     Minus returns Or
	 *     Minus.Minus_1_0 returns Or
	 *     Multiply returns Or
	 *     Multiply.Multiply_1_0 returns Or
	 *     Divide returns Or
	 *     Divide.Divide_1_0 returns Or
	 *     Comparison returns Or
	 *     Comparison.LessThan_1_0_0_1 returns Or
	 *     Comparison.Equal_1_0_1_1 returns Or
	 *     Comparison.GreaterThan_1_0_2_1 returns Or
	 *     Comparison.LessThanOrEqual_1_0_3_1 returns Or
	 *     Comparison.GreaterThanOrEqual_1_0_4_1 returns Or
	 *     PrimaryExpression returns Or
	 *
	 * Constraint:
	 *     (left=Or_Or_1_0 right=And)
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrAccess().getOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrAccess().getRightAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Plus
	 *     Or returns Plus
	 *     Or.Or_1_0 returns Plus
	 *     And returns Plus
	 *     And.And_1_0 returns Plus
	 *     Plus returns Plus
	 *     Plus.Plus_1_0 returns Plus
	 *     Minus returns Plus
	 *     Minus.Minus_1_0 returns Plus
	 *     Multiply returns Plus
	 *     Multiply.Multiply_1_0 returns Plus
	 *     Divide returns Plus
	 *     Divide.Divide_1_0 returns Plus
	 *     Comparison returns Plus
	 *     Comparison.LessThan_1_0_0_1 returns Plus
	 *     Comparison.Equal_1_0_1_1 returns Plus
	 *     Comparison.GreaterThan_1_0_2_1 returns Plus
	 *     Comparison.LessThanOrEqual_1_0_3_1 returns Plus
	 *     Comparison.GreaterThanOrEqual_1_0_4_1 returns Plus
	 *     PrimaryExpression returns Plus
	 *
	 * Constraint:
	 *     (left=Plus_Plus_1_0 right=Minus)
	 */
	protected void sequence_Plus(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangexprPackage.Literals.BINARY_OPERATOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusAccess().getPlusLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusAccess().getRightMinusParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Not
	 *     Or returns Not
	 *     Or.Or_1_0 returns Not
	 *     And returns Not
	 *     And.And_1_0 returns Not
	 *     Plus returns Not
	 *     Plus.Plus_1_0 returns Not
	 *     Minus returns Not
	 *     Minus.Minus_1_0 returns Not
	 *     Multiply returns Not
	 *     Multiply.Multiply_1_0 returns Not
	 *     Divide returns Not
	 *     Divide.Divide_1_0 returns Not
	 *     Comparison returns Not
	 *     Comparison.LessThan_1_0_0_1 returns Not
	 *     Comparison.Equal_1_0_1_1 returns Not
	 *     Comparison.GreaterThan_1_0_2_1 returns Not
	 *     Comparison.LessThanOrEqual_1_0_3_1 returns Not
	 *     Comparison.GreaterThanOrEqual_1_0_4_1 returns Not
	 *     PrimaryExpression returns Not
	 *
	 * Constraint:
	 *     expression=PrimaryExpression
	 */
	protected void sequence_PrimaryExpression(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangexprPackage.Literals.UNARY_OPERATOR__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangexprPackage.Literals.UNARY_OPERATOR__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryExpressionAccess().getExpressionPrimaryExpressionParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ToDouble
	 *     Or returns ToDouble
	 *     Or.Or_1_0 returns ToDouble
	 *     And returns ToDouble
	 *     And.And_1_0 returns ToDouble
	 *     Plus returns ToDouble
	 *     Plus.Plus_1_0 returns ToDouble
	 *     Minus returns ToDouble
	 *     Minus.Minus_1_0 returns ToDouble
	 *     Multiply returns ToDouble
	 *     Multiply.Multiply_1_0 returns ToDouble
	 *     Divide returns ToDouble
	 *     Divide.Divide_1_0 returns ToDouble
	 *     Comparison returns ToDouble
	 *     Comparison.LessThan_1_0_0_1 returns ToDouble
	 *     Comparison.Equal_1_0_1_1 returns ToDouble
	 *     Comparison.GreaterThan_1_0_2_1 returns ToDouble
	 *     Comparison.LessThanOrEqual_1_0_3_1 returns ToDouble
	 *     Comparison.GreaterThanOrEqual_1_0_4_1 returns ToDouble
	 *     PrimaryExpression returns ToDouble
	 *
	 * Constraint:
	 *     expression=PrimaryExpression
	 */
	protected void sequence_PrimaryExpression(ISerializationContext context, ToDouble semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangexprPackage.Literals.UNARY_OPERATOR__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangexprPackage.Literals.UNARY_OPERATOR__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryExpressionAccess().getExpressionPrimaryExpressionParserRuleCall_3_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ToInt
	 *     Or returns ToInt
	 *     Or.Or_1_0 returns ToInt
	 *     And returns ToInt
	 *     And.And_1_0 returns ToInt
	 *     Plus returns ToInt
	 *     Plus.Plus_1_0 returns ToInt
	 *     Minus returns ToInt
	 *     Minus.Minus_1_0 returns ToInt
	 *     Multiply returns ToInt
	 *     Multiply.Multiply_1_0 returns ToInt
	 *     Divide returns ToInt
	 *     Divide.Divide_1_0 returns ToInt
	 *     Comparison returns ToInt
	 *     Comparison.LessThan_1_0_0_1 returns ToInt
	 *     Comparison.Equal_1_0_1_1 returns ToInt
	 *     Comparison.GreaterThan_1_0_2_1 returns ToInt
	 *     Comparison.LessThanOrEqual_1_0_3_1 returns ToInt
	 *     Comparison.GreaterThanOrEqual_1_0_4_1 returns ToInt
	 *     PrimaryExpression returns ToInt
	 *
	 * Constraint:
	 *     expression=PrimaryExpression
	 */
	protected void sequence_PrimaryExpression(ISerializationContext context, ToInt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangexprPackage.Literals.UNARY_OPERATOR__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangexprPackage.Literals.UNARY_OPERATOR__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryExpressionAccess().getExpressionPrimaryExpressionParserRuleCall_4_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns UnaryMinus
	 *     Or returns UnaryMinus
	 *     Or.Or_1_0 returns UnaryMinus
	 *     And returns UnaryMinus
	 *     And.And_1_0 returns UnaryMinus
	 *     Plus returns UnaryMinus
	 *     Plus.Plus_1_0 returns UnaryMinus
	 *     Minus returns UnaryMinus
	 *     Minus.Minus_1_0 returns UnaryMinus
	 *     Multiply returns UnaryMinus
	 *     Multiply.Multiply_1_0 returns UnaryMinus
	 *     Divide returns UnaryMinus
	 *     Divide.Divide_1_0 returns UnaryMinus
	 *     Comparison returns UnaryMinus
	 *     Comparison.LessThan_1_0_0_1 returns UnaryMinus
	 *     Comparison.Equal_1_0_1_1 returns UnaryMinus
	 *     Comparison.GreaterThan_1_0_2_1 returns UnaryMinus
	 *     Comparison.LessThanOrEqual_1_0_3_1 returns UnaryMinus
	 *     Comparison.GreaterThanOrEqual_1_0_4_1 returns UnaryMinus
	 *     PrimaryExpression returns UnaryMinus
	 *
	 * Constraint:
	 *     expression=PrimaryExpression
	 */
	protected void sequence_PrimaryExpression(ISerializationContext context, UnaryMinus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangexprPackage.Literals.UNARY_OPERATOR__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangexprPackage.Literals.UNARY_OPERATOR__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryExpressionAccess().getExpressionPrimaryExpressionParserRuleCall_2_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     (sceneActor=SceneActor spriteActors+=SpriteActor*)
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SceneActor returns SceneActor
	 *
	 * Constraint:
	 *     (name=ID localVariables+=VariableDeclaration* eventHandlers+=EventHandler*)
	 */
	protected void sequence_SceneActor(ISerializationContext context, SceneActor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SendMessage
	 *     SendMessage returns SendMessage
	 *
	 * Constraint:
	 *     name=STRING
	 */
	protected void sequence_SendMessage(ISerializationContext context, SendMessage semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangexprPackage.Literals.SEND_MESSAGE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangexprPackage.Literals.SEND_MESSAGE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSendMessageAccess().getNameSTRINGTerminalRuleCall_3_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Sleep
	 *     Sleep returns Sleep
	 *
	 * Constraint:
	 *     duration=Expression
	 */
	protected void sequence_Sleep(ISerializationContext context, Sleep semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangexprPackage.Literals.SLEEP__DURATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangexprPackage.Literals.SLEEP__DURATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSleepAccess().getDurationExpressionParserRuleCall_3_0(), semanticObject.getDuration());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpriteActor returns SpriteActor
	 *
	 * Constraint:
	 *     (name=ID localVariables+=VariableDeclaration* eventHandlers+=EventHandler*)
	 */
	protected void sequence_SpriteActor(ISerializationContext context, SpriteActor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns VariableAssignment
	 *     VariableAssignment returns VariableAssignment
	 *
	 * Constraint:
	 *     (variableName=ID expression=Expression)
	 */
	protected void sequence_VariableAssignment(ISerializationContext context, VariableAssignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangexprPackage.Literals.VARIABLE_ASSIGNMENT__VARIABLE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangexprPackage.Literals.VARIABLE_ASSIGNMENT__VARIABLE_NAME));
			if (transientValues.isValueTransient(semanticObject, KlangexprPackage.Literals.VARIABLE_ASSIGNMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangexprPackage.Literals.VARIABLE_ASSIGNMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAssignmentAccess().getVariableNameIDTerminalRuleCall_0_0(), semanticObject.getVariableName());
		feeder.accept(grammarAccess.getVariableAssignmentAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclaration returns VariableDeclaration
	 *
	 * Constraint:
	 *     (name=ID expression=Expression)
	 */
	protected void sequence_VariableDeclaration(ISerializationContext context, VariableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.VARIABLE_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.VARIABLE_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.VARIABLE_DECLARATION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.VARIABLE_DECLARATION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getExpressionExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns WhileLoop
	 *     WhileLoop returns WhileLoop
	 *
	 * Constraint:
	 *     (predicate=Expression statements+=Statement*)
	 */
	protected void sequence_WhileLoop(ISerializationContext context, WhileLoop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
