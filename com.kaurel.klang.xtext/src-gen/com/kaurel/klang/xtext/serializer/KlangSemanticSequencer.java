/*
 * generated by Xtext 2.10.0-SNAPSHOT
 */
package com.kaurel.klang.xtext.serializer;

import com.google.inject.Inject;
import com.kaurel.klang.xtext.services.KlangGrammarAccess;
import java.util.Set;
import klang.And;
import klang.Assignment;
import klang.BooleanLiteral;
import klang.Divide;
import klang.Equal;
import klang.EventHandler;
import klang.ForeverLoop;
import klang.Game;
import klang.GreaterThan;
import klang.If;
import klang.KlangPackage;
import klang.LessThan;
import klang.Minus;
import klang.Multiply;
import klang.Not;
import klang.NumericLiteral;
import klang.Or;
import klang.Plus;
import klang.Sprite;
import klang.StringLiteral;
import klang.SubroutineCall;
import klang.Variable;
import klang.VariableRef;
import klang.WhileLoop;
import klang.Yield;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class KlangSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private KlangGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == KlangPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case KlangPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case KlangPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case KlangPackage.BOOLEAN_LITERAL:
				sequence_AtomicExpression(context, (BooleanLiteral) semanticObject); 
				return; 
			case KlangPackage.DIVIDE:
				sequence_Divide(context, (Divide) semanticObject); 
				return; 
			case KlangPackage.EQUAL:
				sequence_Comparison(context, (Equal) semanticObject); 
				return; 
			case KlangPackage.EVENT_HANDLER:
				sequence_EventHandler(context, (EventHandler) semanticObject); 
				return; 
			case KlangPackage.FOREVER_LOOP:
				sequence_ForeverLoop(context, (ForeverLoop) semanticObject); 
				return; 
			case KlangPackage.GAME:
				sequence_Game(context, (Game) semanticObject); 
				return; 
			case KlangPackage.GREATER_THAN:
				sequence_Comparison(context, (GreaterThan) semanticObject); 
				return; 
			case KlangPackage.IF:
				sequence_If(context, (If) semanticObject); 
				return; 
			case KlangPackage.LESS_THAN:
				sequence_Comparison(context, (LessThan) semanticObject); 
				return; 
			case KlangPackage.MINUS:
				sequence_Minus(context, (Minus) semanticObject); 
				return; 
			case KlangPackage.MULTIPLY:
				sequence_Multiply(context, (Multiply) semanticObject); 
				return; 
			case KlangPackage.NOT:
				sequence_PrimaryExpression(context, (Not) semanticObject); 
				return; 
			case KlangPackage.NUMERIC_LITERAL:
				sequence_AtomicExpression(context, (NumericLiteral) semanticObject); 
				return; 
			case KlangPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case KlangPackage.PLUS:
				sequence_Plus(context, (Plus) semanticObject); 
				return; 
			case KlangPackage.SPRITE:
				sequence_Sprite(context, (Sprite) semanticObject); 
				return; 
			case KlangPackage.STRING_LITERAL:
				sequence_AtomicExpression(context, (StringLiteral) semanticObject); 
				return; 
			case KlangPackage.SUBROUTINE_CALL:
				sequence_SubroutineCall(context, (SubroutineCall) semanticObject); 
				return; 
			case KlangPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case KlangPackage.VARIABLE_REF:
				sequence_AtomicExpression(context, (VariableRef) semanticObject); 
				return; 
			case KlangPackage.WHILE_LOOP:
				sequence_WhileLoop(context, (WhileLoop) semanticObject); 
				return; 
			case KlangPackage.YIELD:
				sequence_Yield(context, (Yield) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expression returns And
	 *     Or returns And
	 *     Or.Or_1_0 returns And
	 *     And returns And
	 *     And.And_1_0 returns And
	 *     Plus returns And
	 *     Plus.Plus_1_0 returns And
	 *     Minus returns And
	 *     Minus.Minus_1_0 returns And
	 *     Multiply returns And
	 *     Multiply.Multiply_1_0 returns And
	 *     Divide returns And
	 *     Divide.Divide_1_0 returns And
	 *     Comparison returns And
	 *     Comparison.LessThan_1_0_0_1 returns And
	 *     Comparison.Equal_1_0_1_1 returns And
	 *     Comparison.GreaterThan_1_0_2_1 returns And
	 *     PrimaryExpression returns And
	 *
	 * Constraint:
	 *     (left=And_And_1_0 right=Comparison)
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndAccess().getAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndAccess().getRightComparisonParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Assignment
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (variable=[Variable|ID] expression=Expression)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.ASSIGNMENT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.ASSIGNMENT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.ASSIGNMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.ASSIGNMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getVariableVariableIDTerminalRuleCall_0_0_1(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getAssignmentAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BooleanLiteral
	 *     Or returns BooleanLiteral
	 *     Or.Or_1_0 returns BooleanLiteral
	 *     And returns BooleanLiteral
	 *     And.And_1_0 returns BooleanLiteral
	 *     Plus returns BooleanLiteral
	 *     Plus.Plus_1_0 returns BooleanLiteral
	 *     Minus returns BooleanLiteral
	 *     Minus.Minus_1_0 returns BooleanLiteral
	 *     Multiply returns BooleanLiteral
	 *     Multiply.Multiply_1_0 returns BooleanLiteral
	 *     Divide returns BooleanLiteral
	 *     Divide.Divide_1_0 returns BooleanLiteral
	 *     Comparison returns BooleanLiteral
	 *     Comparison.LessThan_1_0_0_1 returns BooleanLiteral
	 *     Comparison.Equal_1_0_1_1 returns BooleanLiteral
	 *     Comparison.GreaterThan_1_0_2_1 returns BooleanLiteral
	 *     PrimaryExpression returns BooleanLiteral
	 *     AtomicExpression returns BooleanLiteral
	 *
	 * Constraint:
	 *     value?='true'?
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, BooleanLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NumericLiteral
	 *     Or returns NumericLiteral
	 *     Or.Or_1_0 returns NumericLiteral
	 *     And returns NumericLiteral
	 *     And.And_1_0 returns NumericLiteral
	 *     Plus returns NumericLiteral
	 *     Plus.Plus_1_0 returns NumericLiteral
	 *     Minus returns NumericLiteral
	 *     Minus.Minus_1_0 returns NumericLiteral
	 *     Multiply returns NumericLiteral
	 *     Multiply.Multiply_1_0 returns NumericLiteral
	 *     Divide returns NumericLiteral
	 *     Divide.Divide_1_0 returns NumericLiteral
	 *     Comparison returns NumericLiteral
	 *     Comparison.LessThan_1_0_0_1 returns NumericLiteral
	 *     Comparison.Equal_1_0_1_1 returns NumericLiteral
	 *     Comparison.GreaterThan_1_0_2_1 returns NumericLiteral
	 *     PrimaryExpression returns NumericLiteral
	 *     AtomicExpression returns NumericLiteral
	 *
	 * Constraint:
	 *     value=NUMERIC
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, NumericLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.NUMERIC_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.NUMERIC_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getValueNUMERICTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns StringLiteral
	 *     Or returns StringLiteral
	 *     Or.Or_1_0 returns StringLiteral
	 *     And returns StringLiteral
	 *     And.And_1_0 returns StringLiteral
	 *     Plus returns StringLiteral
	 *     Plus.Plus_1_0 returns StringLiteral
	 *     Minus returns StringLiteral
	 *     Minus.Minus_1_0 returns StringLiteral
	 *     Multiply returns StringLiteral
	 *     Multiply.Multiply_1_0 returns StringLiteral
	 *     Divide returns StringLiteral
	 *     Divide.Divide_1_0 returns StringLiteral
	 *     Comparison returns StringLiteral
	 *     Comparison.LessThan_1_0_0_1 returns StringLiteral
	 *     Comparison.Equal_1_0_1_1 returns StringLiteral
	 *     Comparison.GreaterThan_1_0_2_1 returns StringLiteral
	 *     PrimaryExpression returns StringLiteral
	 *     AtomicExpression returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getValueSTRINGTerminalRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns VariableRef
	 *     Or returns VariableRef
	 *     Or.Or_1_0 returns VariableRef
	 *     And returns VariableRef
	 *     And.And_1_0 returns VariableRef
	 *     Plus returns VariableRef
	 *     Plus.Plus_1_0 returns VariableRef
	 *     Minus returns VariableRef
	 *     Minus.Minus_1_0 returns VariableRef
	 *     Multiply returns VariableRef
	 *     Multiply.Multiply_1_0 returns VariableRef
	 *     Divide returns VariableRef
	 *     Divide.Divide_1_0 returns VariableRef
	 *     Comparison returns VariableRef
	 *     Comparison.LessThan_1_0_0_1 returns VariableRef
	 *     Comparison.Equal_1_0_1_1 returns VariableRef
	 *     Comparison.GreaterThan_1_0_2_1 returns VariableRef
	 *     PrimaryExpression returns VariableRef
	 *     AtomicExpression returns VariableRef
	 *
	 * Constraint:
	 *     variableName=ID
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, VariableRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.VARIABLE_REF__VARIABLE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.VARIABLE_REF__VARIABLE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getVariableNameIDTerminalRuleCall_3_1_0(), semanticObject.getVariableName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Equal
	 *     Or returns Equal
	 *     Or.Or_1_0 returns Equal
	 *     And returns Equal
	 *     And.And_1_0 returns Equal
	 *     Plus returns Equal
	 *     Plus.Plus_1_0 returns Equal
	 *     Minus returns Equal
	 *     Minus.Minus_1_0 returns Equal
	 *     Multiply returns Equal
	 *     Multiply.Multiply_1_0 returns Equal
	 *     Divide returns Equal
	 *     Divide.Divide_1_0 returns Equal
	 *     Comparison returns Equal
	 *     Comparison.LessThan_1_0_0_1 returns Equal
	 *     Comparison.Equal_1_0_1_1 returns Equal
	 *     Comparison.GreaterThan_1_0_2_1 returns Equal
	 *     PrimaryExpression returns Equal
	 *
	 * Constraint:
	 *     (left=Comparison_Equal_1_0_1_1 right=Plus)
	 */
	protected void sequence_Comparison(ISerializationContext context, Equal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getEqualLeftAction_1_0_1_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonAccess().getRightPlusParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns GreaterThan
	 *     Or returns GreaterThan
	 *     Or.Or_1_0 returns GreaterThan
	 *     And returns GreaterThan
	 *     And.And_1_0 returns GreaterThan
	 *     Plus returns GreaterThan
	 *     Plus.Plus_1_0 returns GreaterThan
	 *     Minus returns GreaterThan
	 *     Minus.Minus_1_0 returns GreaterThan
	 *     Multiply returns GreaterThan
	 *     Multiply.Multiply_1_0 returns GreaterThan
	 *     Divide returns GreaterThan
	 *     Divide.Divide_1_0 returns GreaterThan
	 *     Comparison returns GreaterThan
	 *     Comparison.LessThan_1_0_0_1 returns GreaterThan
	 *     Comparison.Equal_1_0_1_1 returns GreaterThan
	 *     Comparison.GreaterThan_1_0_2_1 returns GreaterThan
	 *     PrimaryExpression returns GreaterThan
	 *
	 * Constraint:
	 *     (left=Comparison_GreaterThan_1_0_2_1 right=Plus)
	 */
	protected void sequence_Comparison(ISerializationContext context, GreaterThan semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.GREATER_THAN__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.GREATER_THAN__LEFT));
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.GREATER_THAN__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.GREATER_THAN__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getGreaterThanLeftAction_1_0_2_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonAccess().getRightPlusParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LessThan
	 *     Or returns LessThan
	 *     Or.Or_1_0 returns LessThan
	 *     And returns LessThan
	 *     And.And_1_0 returns LessThan
	 *     Plus returns LessThan
	 *     Plus.Plus_1_0 returns LessThan
	 *     Minus returns LessThan
	 *     Minus.Minus_1_0 returns LessThan
	 *     Multiply returns LessThan
	 *     Multiply.Multiply_1_0 returns LessThan
	 *     Divide returns LessThan
	 *     Divide.Divide_1_0 returns LessThan
	 *     Comparison returns LessThan
	 *     Comparison.LessThan_1_0_0_1 returns LessThan
	 *     Comparison.Equal_1_0_1_1 returns LessThan
	 *     Comparison.GreaterThan_1_0_2_1 returns LessThan
	 *     PrimaryExpression returns LessThan
	 *
	 * Constraint:
	 *     (left=Comparison_LessThan_1_0_0_1 right=Plus)
	 */
	protected void sequence_Comparison(ISerializationContext context, LessThan semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getLessThanLeftAction_1_0_0_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonAccess().getRightPlusParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Divide
	 *     Or returns Divide
	 *     Or.Or_1_0 returns Divide
	 *     And returns Divide
	 *     And.And_1_0 returns Divide
	 *     Plus returns Divide
	 *     Plus.Plus_1_0 returns Divide
	 *     Minus returns Divide
	 *     Minus.Minus_1_0 returns Divide
	 *     Multiply returns Divide
	 *     Multiply.Multiply_1_0 returns Divide
	 *     Divide returns Divide
	 *     Divide.Divide_1_0 returns Divide
	 *     Comparison returns Divide
	 *     Comparison.LessThan_1_0_0_1 returns Divide
	 *     Comparison.Equal_1_0_1_1 returns Divide
	 *     Comparison.GreaterThan_1_0_2_1 returns Divide
	 *     PrimaryExpression returns Divide
	 *
	 * Constraint:
	 *     (left=Divide_Divide_1_0 right=PrimaryExpression)
	 */
	protected void sequence_Divide(ISerializationContext context, Divide semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDivideAccess().getDivideLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getDivideAccess().getRightPrimaryExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EventHandler returns EventHandler
	 *
	 * Constraint:
	 *     (eventType=EventType statements+=Statement*)
	 */
	protected void sequence_EventHandler(ISerializationContext context, EventHandler semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ForeverLoop returns ForeverLoop
	 *     Statement returns ForeverLoop
	 *     ControlStatement returns ForeverLoop
	 *
	 * Constraint:
	 *     loopStatements+=Statement*
	 */
	protected void sequence_ForeverLoop(ISerializationContext context, ForeverLoop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Game returns Game
	 *
	 * Constraint:
	 *     (variables+=Variable* actorDefs+=Sprite*)
	 */
	protected void sequence_Game(ISerializationContext context, Game semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     If returns If
	 *     Statement returns If
	 *     ControlStatement returns If
	 *
	 * Constraint:
	 *     (predicate=Expression ifBlock+=Statement*)
	 */
	protected void sequence_If(ISerializationContext context, If semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Minus
	 *     Or returns Minus
	 *     Or.Or_1_0 returns Minus
	 *     And returns Minus
	 *     And.And_1_0 returns Minus
	 *     Plus returns Minus
	 *     Plus.Plus_1_0 returns Minus
	 *     Minus returns Minus
	 *     Minus.Minus_1_0 returns Minus
	 *     Multiply returns Minus
	 *     Multiply.Multiply_1_0 returns Minus
	 *     Divide returns Minus
	 *     Divide.Divide_1_0 returns Minus
	 *     Comparison returns Minus
	 *     Comparison.LessThan_1_0_0_1 returns Minus
	 *     Comparison.Equal_1_0_1_1 returns Minus
	 *     Comparison.GreaterThan_1_0_2_1 returns Minus
	 *     PrimaryExpression returns Minus
	 *
	 * Constraint:
	 *     (left=Minus_Minus_1_0 right=Multiply)
	 */
	protected void sequence_Minus(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMinusAccess().getMinusLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMinusAccess().getRightMultiplyParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Multiply
	 *     Or returns Multiply
	 *     Or.Or_1_0 returns Multiply
	 *     And returns Multiply
	 *     And.And_1_0 returns Multiply
	 *     Plus returns Multiply
	 *     Plus.Plus_1_0 returns Multiply
	 *     Minus returns Multiply
	 *     Minus.Minus_1_0 returns Multiply
	 *     Multiply returns Multiply
	 *     Multiply.Multiply_1_0 returns Multiply
	 *     Divide returns Multiply
	 *     Divide.Divide_1_0 returns Multiply
	 *     Comparison returns Multiply
	 *     Comparison.LessThan_1_0_0_1 returns Multiply
	 *     Comparison.Equal_1_0_1_1 returns Multiply
	 *     Comparison.GreaterThan_1_0_2_1 returns Multiply
	 *     PrimaryExpression returns Multiply
	 *
	 * Constraint:
	 *     (left=Multiply_Multiply_1_0 right=Divide)
	 */
	protected void sequence_Multiply(ISerializationContext context, Multiply semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplyAccess().getMultiplyLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplyAccess().getRightDivideParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Or
	 *     Or returns Or
	 *     Or.Or_1_0 returns Or
	 *     And returns Or
	 *     And.And_1_0 returns Or
	 *     Plus returns Or
	 *     Plus.Plus_1_0 returns Or
	 *     Minus returns Or
	 *     Minus.Minus_1_0 returns Or
	 *     Multiply returns Or
	 *     Multiply.Multiply_1_0 returns Or
	 *     Divide returns Or
	 *     Divide.Divide_1_0 returns Or
	 *     Comparison returns Or
	 *     Comparison.LessThan_1_0_0_1 returns Or
	 *     Comparison.Equal_1_0_1_1 returns Or
	 *     Comparison.GreaterThan_1_0_2_1 returns Or
	 *     PrimaryExpression returns Or
	 *
	 * Constraint:
	 *     (left=Or_Or_1_0 right=And)
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrAccess().getOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrAccess().getRightAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Plus
	 *     Or returns Plus
	 *     Or.Or_1_0 returns Plus
	 *     And returns Plus
	 *     And.And_1_0 returns Plus
	 *     Plus returns Plus
	 *     Plus.Plus_1_0 returns Plus
	 *     Minus returns Plus
	 *     Minus.Minus_1_0 returns Plus
	 *     Multiply returns Plus
	 *     Multiply.Multiply_1_0 returns Plus
	 *     Divide returns Plus
	 *     Divide.Divide_1_0 returns Plus
	 *     Comparison returns Plus
	 *     Comparison.LessThan_1_0_0_1 returns Plus
	 *     Comparison.Equal_1_0_1_1 returns Plus
	 *     Comparison.GreaterThan_1_0_2_1 returns Plus
	 *     PrimaryExpression returns Plus
	 *
	 * Constraint:
	 *     (left=Plus_Plus_1_0 right=Minus)
	 */
	protected void sequence_Plus(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusAccess().getPlusLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusAccess().getRightMinusParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Not
	 *     Or returns Not
	 *     Or.Or_1_0 returns Not
	 *     And returns Not
	 *     And.And_1_0 returns Not
	 *     Plus returns Not
	 *     Plus.Plus_1_0 returns Not
	 *     Minus returns Not
	 *     Minus.Minus_1_0 returns Not
	 *     Multiply returns Not
	 *     Multiply.Multiply_1_0 returns Not
	 *     Divide returns Not
	 *     Divide.Divide_1_0 returns Not
	 *     Comparison returns Not
	 *     Comparison.LessThan_1_0_0_1 returns Not
	 *     Comparison.Equal_1_0_1_1 returns Not
	 *     Comparison.GreaterThan_1_0_2_1 returns Not
	 *     PrimaryExpression returns Not
	 *
	 * Constraint:
	 *     expression=PrimaryExpression
	 */
	protected void sequence_PrimaryExpression(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.UNARY_OPERATOR__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.UNARY_OPERATOR__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryExpressionAccess().getExpressionPrimaryExpressionParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Sprite returns Sprite
	 *
	 * Constraint:
	 *     (name=ID variables+=Variable* eventHandlers+=EventHandler*)
	 */
	protected void sequence_Sprite(ISerializationContext context, Sprite semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SubroutineCall
	 *     SubroutineCall returns SubroutineCall
	 *
	 * Constraint:
	 *     (name=ID parameters+=Expression? parameters+=Expression*)
	 */
	protected void sequence_SubroutineCall(ISerializationContext context, SubroutineCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Variable
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     (name=ID expression=Expression)
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.VARIABLE__NAME));
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.VARIABLE__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.VARIABLE__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVariableAccess().getExpressionExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     WhileLoop returns WhileLoop
	 *     Statement returns WhileLoop
	 *     ControlStatement returns WhileLoop
	 *
	 * Constraint:
	 *     (predicate=Expression loopBlock+=Statement*)
	 */
	protected void sequence_WhileLoop(ISerializationContext context, WhileLoop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Yield
	 *     ControlStatement returns Yield
	 *     Yield returns Yield
	 *
	 * Constraint:
	 *     {Yield}
	 */
	protected void sequence_Yield(ISerializationContext context, Yield semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
