/*
 * generated by Xtext 2.10.0-SNAPSHOT
 */
package com.kaurel.klang.xtext.serializer;

import com.google.inject.Inject;
import com.kaurel.klang.xtext.services.KlangGrammarAccess;
import java.util.Set;
import klang.Actor;
import klang.And;
import klang.BooleanLiteral;
import klang.CollidesWith;
import klang.Divide;
import klang.DoubleLiteral;
import klang.Equal;
import klang.ForeverLoop;
import klang.FunctionCall;
import klang.Game;
import klang.GameStart;
import klang.GreaterThan;
import klang.If;
import klang.KeyPressed;
import klang.KlangPackage;
import klang.LessThan;
import klang.Minus;
import klang.Multiply;
import klang.Not;
import klang.Or;
import klang.Plus;
import klang.SceneEntity;
import klang.Sleep;
import klang.SpriteClicked;
import klang.SpriteEntity;
import klang.StringLiteral;
import klang.Variable;
import klang.VariableAssignment;
import klang.VariableRef;
import klang.WhileLoop;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class KlangSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private KlangGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == KlangPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case KlangPackage.ACTOR:
				sequence_Actor(context, (Actor) semanticObject); 
				return; 
			case KlangPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case KlangPackage.BOOLEAN_LITERAL:
				sequence_AtomicExpression(context, (BooleanLiteral) semanticObject); 
				return; 
			case KlangPackage.COLLIDES_WITH:
				sequence_CollidesWith(context, (CollidesWith) semanticObject); 
				return; 
			case KlangPackage.DIVIDE:
				sequence_Divide(context, (Divide) semanticObject); 
				return; 
			case KlangPackage.DOUBLE_LITERAL:
				sequence_AtomicExpression(context, (DoubleLiteral) semanticObject); 
				return; 
			case KlangPackage.EQUAL:
				sequence_Comparison(context, (Equal) semanticObject); 
				return; 
			case KlangPackage.FOREVER_LOOP:
				sequence_ForeverLoop(context, (ForeverLoop) semanticObject); 
				return; 
			case KlangPackage.FUNCTION_CALL:
				sequence_FunctionCall(context, (FunctionCall) semanticObject); 
				return; 
			case KlangPackage.GAME:
				sequence_Game(context, (Game) semanticObject); 
				return; 
			case KlangPackage.GAME_START:
				sequence_GameStart(context, (GameStart) semanticObject); 
				return; 
			case KlangPackage.GREATER_THAN:
				sequence_Comparison(context, (GreaterThan) semanticObject); 
				return; 
			case KlangPackage.IF:
				sequence_If(context, (If) semanticObject); 
				return; 
			case KlangPackage.KEY_PRESSED:
				sequence_KeyPressed(context, (KeyPressed) semanticObject); 
				return; 
			case KlangPackage.LESS_THAN:
				sequence_Comparison(context, (LessThan) semanticObject); 
				return; 
			case KlangPackage.MINUS:
				sequence_Minus(context, (Minus) semanticObject); 
				return; 
			case KlangPackage.MULTIPLY:
				sequence_Multiply(context, (Multiply) semanticObject); 
				return; 
			case KlangPackage.NOT:
				sequence_PrimaryExpression(context, (Not) semanticObject); 
				return; 
			case KlangPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case KlangPackage.PLUS:
				sequence_Plus(context, (Plus) semanticObject); 
				return; 
			case KlangPackage.SCENE_ENTITY:
				sequence_Entity(context, (SceneEntity) semanticObject); 
				return; 
			case KlangPackage.SLEEP:
				sequence_Sleep(context, (Sleep) semanticObject); 
				return; 
			case KlangPackage.SPRITE_CLICKED:
				sequence_SpriteClicked(context, (SpriteClicked) semanticObject); 
				return; 
			case KlangPackage.SPRITE_ENTITY:
				sequence_Entity(context, (SpriteEntity) semanticObject); 
				return; 
			case KlangPackage.STRING_LITERAL:
				sequence_AtomicExpression(context, (StringLiteral) semanticObject); 
				return; 
			case KlangPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case KlangPackage.VARIABLE_ASSIGNMENT:
				sequence_VariableAssignment(context, (VariableAssignment) semanticObject); 
				return; 
			case KlangPackage.VARIABLE_REF:
				sequence_AtomicExpression(context, (VariableRef) semanticObject); 
				return; 
			case KlangPackage.WHILE_LOOP:
				sequence_WhileLoop(context, (WhileLoop) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Actor returns Actor
	 *
	 * Constraint:
	 *     (entity=Entity variableDeclarations+=Variable* eventHandlers+=EventHandler*)
	 */
	protected void sequence_Actor(ISerializationContext context, Actor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns And
	 *     Expression returns And
	 *     Or returns And
	 *     Or.Or_1_0 returns And
	 *     And returns And
	 *     And.And_1_0 returns And
	 *     Plus returns And
	 *     Plus.Plus_1_0 returns And
	 *     Minus returns And
	 *     Minus.Minus_1_0 returns And
	 *     Multiply returns And
	 *     Multiply.Multiply_1_0 returns And
	 *     Divide returns And
	 *     Divide.Divide_1_0 returns And
	 *     Comparison returns And
	 *     Comparison.LessThan_1_0_0_1 returns And
	 *     Comparison.Equal_1_0_1_1 returns And
	 *     Comparison.GreaterThan_1_0_2_1 returns And
	 *     PrimaryExpression returns And
	 *
	 * Constraint:
	 *     (left=And_And_1_0 right=Comparison)
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndAccess().getAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndAccess().getRightComparisonParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns BooleanLiteral
	 *     Expression returns BooleanLiteral
	 *     Or returns BooleanLiteral
	 *     Or.Or_1_0 returns BooleanLiteral
	 *     And returns BooleanLiteral
	 *     And.And_1_0 returns BooleanLiteral
	 *     Plus returns BooleanLiteral
	 *     Plus.Plus_1_0 returns BooleanLiteral
	 *     Minus returns BooleanLiteral
	 *     Minus.Minus_1_0 returns BooleanLiteral
	 *     Multiply returns BooleanLiteral
	 *     Multiply.Multiply_1_0 returns BooleanLiteral
	 *     Divide returns BooleanLiteral
	 *     Divide.Divide_1_0 returns BooleanLiteral
	 *     Comparison returns BooleanLiteral
	 *     Comparison.LessThan_1_0_0_1 returns BooleanLiteral
	 *     Comparison.Equal_1_0_1_1 returns BooleanLiteral
	 *     Comparison.GreaterThan_1_0_2_1 returns BooleanLiteral
	 *     PrimaryExpression returns BooleanLiteral
	 *     AtomicExpression returns BooleanLiteral
	 *
	 * Constraint:
	 *     value?='true'?
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, BooleanLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns DoubleLiteral
	 *     Expression returns DoubleLiteral
	 *     Or returns DoubleLiteral
	 *     Or.Or_1_0 returns DoubleLiteral
	 *     And returns DoubleLiteral
	 *     And.And_1_0 returns DoubleLiteral
	 *     Plus returns DoubleLiteral
	 *     Plus.Plus_1_0 returns DoubleLiteral
	 *     Minus returns DoubleLiteral
	 *     Minus.Minus_1_0 returns DoubleLiteral
	 *     Multiply returns DoubleLiteral
	 *     Multiply.Multiply_1_0 returns DoubleLiteral
	 *     Divide returns DoubleLiteral
	 *     Divide.Divide_1_0 returns DoubleLiteral
	 *     Comparison returns DoubleLiteral
	 *     Comparison.LessThan_1_0_0_1 returns DoubleLiteral
	 *     Comparison.Equal_1_0_1_1 returns DoubleLiteral
	 *     Comparison.GreaterThan_1_0_2_1 returns DoubleLiteral
	 *     PrimaryExpression returns DoubleLiteral
	 *     AtomicExpression returns DoubleLiteral
	 *
	 * Constraint:
	 *     value=DECIMAL
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, DoubleLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.DOUBLE_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.DOUBLE_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getValueDECIMALTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns StringLiteral
	 *     Expression returns StringLiteral
	 *     Or returns StringLiteral
	 *     Or.Or_1_0 returns StringLiteral
	 *     And returns StringLiteral
	 *     And.And_1_0 returns StringLiteral
	 *     Plus returns StringLiteral
	 *     Plus.Plus_1_0 returns StringLiteral
	 *     Minus returns StringLiteral
	 *     Minus.Minus_1_0 returns StringLiteral
	 *     Multiply returns StringLiteral
	 *     Multiply.Multiply_1_0 returns StringLiteral
	 *     Divide returns StringLiteral
	 *     Divide.Divide_1_0 returns StringLiteral
	 *     Comparison returns StringLiteral
	 *     Comparison.LessThan_1_0_0_1 returns StringLiteral
	 *     Comparison.Equal_1_0_1_1 returns StringLiteral
	 *     Comparison.GreaterThan_1_0_2_1 returns StringLiteral
	 *     PrimaryExpression returns StringLiteral
	 *     AtomicExpression returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getValueSTRINGTerminalRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns VariableRef
	 *     Expression returns VariableRef
	 *     Or returns VariableRef
	 *     Or.Or_1_0 returns VariableRef
	 *     And returns VariableRef
	 *     And.And_1_0 returns VariableRef
	 *     Plus returns VariableRef
	 *     Plus.Plus_1_0 returns VariableRef
	 *     Minus returns VariableRef
	 *     Minus.Minus_1_0 returns VariableRef
	 *     Multiply returns VariableRef
	 *     Multiply.Multiply_1_0 returns VariableRef
	 *     Divide returns VariableRef
	 *     Divide.Divide_1_0 returns VariableRef
	 *     Comparison returns VariableRef
	 *     Comparison.LessThan_1_0_0_1 returns VariableRef
	 *     Comparison.Equal_1_0_1_1 returns VariableRef
	 *     Comparison.GreaterThan_1_0_2_1 returns VariableRef
	 *     PrimaryExpression returns VariableRef
	 *     AtomicExpression returns VariableRef
	 *
	 * Constraint:
	 *     variableName=ID
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, VariableRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.VARIABLE_REF__VARIABLE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.VARIABLE_REF__VARIABLE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getVariableNameIDTerminalRuleCall_3_1_0(), semanticObject.getVariableName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EventHandler returns CollidesWith
	 *     CollidesWith returns CollidesWith
	 *
	 * Constraint:
	 *     (target=[SpriteEntity|ID] statements+=Statement*)
	 */
	protected void sequence_CollidesWith(ISerializationContext context, CollidesWith semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns Equal
	 *     Expression returns Equal
	 *     Or returns Equal
	 *     Or.Or_1_0 returns Equal
	 *     And returns Equal
	 *     And.And_1_0 returns Equal
	 *     Plus returns Equal
	 *     Plus.Plus_1_0 returns Equal
	 *     Minus returns Equal
	 *     Minus.Minus_1_0 returns Equal
	 *     Multiply returns Equal
	 *     Multiply.Multiply_1_0 returns Equal
	 *     Divide returns Equal
	 *     Divide.Divide_1_0 returns Equal
	 *     Comparison returns Equal
	 *     Comparison.LessThan_1_0_0_1 returns Equal
	 *     Comparison.Equal_1_0_1_1 returns Equal
	 *     Comparison.GreaterThan_1_0_2_1 returns Equal
	 *     PrimaryExpression returns Equal
	 *
	 * Constraint:
	 *     (left=Comparison_Equal_1_0_1_1 right=Plus)
	 */
	protected void sequence_Comparison(ISerializationContext context, Equal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getEqualLeftAction_1_0_1_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonAccess().getRightPlusParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns GreaterThan
	 *     Expression returns GreaterThan
	 *     Or returns GreaterThan
	 *     Or.Or_1_0 returns GreaterThan
	 *     And returns GreaterThan
	 *     And.And_1_0 returns GreaterThan
	 *     Plus returns GreaterThan
	 *     Plus.Plus_1_0 returns GreaterThan
	 *     Minus returns GreaterThan
	 *     Minus.Minus_1_0 returns GreaterThan
	 *     Multiply returns GreaterThan
	 *     Multiply.Multiply_1_0 returns GreaterThan
	 *     Divide returns GreaterThan
	 *     Divide.Divide_1_0 returns GreaterThan
	 *     Comparison returns GreaterThan
	 *     Comparison.LessThan_1_0_0_1 returns GreaterThan
	 *     Comparison.Equal_1_0_1_1 returns GreaterThan
	 *     Comparison.GreaterThan_1_0_2_1 returns GreaterThan
	 *     PrimaryExpression returns GreaterThan
	 *
	 * Constraint:
	 *     (left=Comparison_GreaterThan_1_0_2_1 right=Plus)
	 */
	protected void sequence_Comparison(ISerializationContext context, GreaterThan semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.GREATER_THAN__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.GREATER_THAN__LEFT));
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.GREATER_THAN__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.GREATER_THAN__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getGreaterThanLeftAction_1_0_2_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonAccess().getRightPlusParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns LessThan
	 *     Expression returns LessThan
	 *     Or returns LessThan
	 *     Or.Or_1_0 returns LessThan
	 *     And returns LessThan
	 *     And.And_1_0 returns LessThan
	 *     Plus returns LessThan
	 *     Plus.Plus_1_0 returns LessThan
	 *     Minus returns LessThan
	 *     Minus.Minus_1_0 returns LessThan
	 *     Multiply returns LessThan
	 *     Multiply.Multiply_1_0 returns LessThan
	 *     Divide returns LessThan
	 *     Divide.Divide_1_0 returns LessThan
	 *     Comparison returns LessThan
	 *     Comparison.LessThan_1_0_0_1 returns LessThan
	 *     Comparison.Equal_1_0_1_1 returns LessThan
	 *     Comparison.GreaterThan_1_0_2_1 returns LessThan
	 *     PrimaryExpression returns LessThan
	 *
	 * Constraint:
	 *     (left=Comparison_LessThan_1_0_0_1 right=Plus)
	 */
	protected void sequence_Comparison(ISerializationContext context, LessThan semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getLessThanLeftAction_1_0_0_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonAccess().getRightPlusParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns Divide
	 *     Expression returns Divide
	 *     Or returns Divide
	 *     Or.Or_1_0 returns Divide
	 *     And returns Divide
	 *     And.And_1_0 returns Divide
	 *     Plus returns Divide
	 *     Plus.Plus_1_0 returns Divide
	 *     Minus returns Divide
	 *     Minus.Minus_1_0 returns Divide
	 *     Multiply returns Divide
	 *     Multiply.Multiply_1_0 returns Divide
	 *     Divide returns Divide
	 *     Divide.Divide_1_0 returns Divide
	 *     Comparison returns Divide
	 *     Comparison.LessThan_1_0_0_1 returns Divide
	 *     Comparison.Equal_1_0_1_1 returns Divide
	 *     Comparison.GreaterThan_1_0_2_1 returns Divide
	 *     PrimaryExpression returns Divide
	 *
	 * Constraint:
	 *     (left=Divide_Divide_1_0 right=PrimaryExpression)
	 */
	protected void sequence_Divide(ISerializationContext context, Divide semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDivideAccess().getDivideLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getDivideAccess().getRightPrimaryExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns SceneEntity
	 *
	 * Constraint:
	 *     {SceneEntity}
	 */
	protected void sequence_Entity(ISerializationContext context, SceneEntity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns SpriteEntity
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Entity(ISerializationContext context, SpriteEntity semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.SPRITE_ENTITY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.SPRITE_ENTITY__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEntityAccess().getNameIDTerminalRuleCall_0_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ForeverLoop
	 *     ForeverLoop returns ForeverLoop
	 *
	 * Constraint:
	 *     loopStatements+=Statement*
	 */
	protected void sequence_ForeverLoop(ISerializationContext context, ForeverLoop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns FunctionCall
	 *     AbstractElement returns FunctionCall
	 *     Expression returns FunctionCall
	 *     Or returns FunctionCall
	 *     Or.Or_1_0 returns FunctionCall
	 *     And returns FunctionCall
	 *     And.And_1_0 returns FunctionCall
	 *     Plus returns FunctionCall
	 *     Plus.Plus_1_0 returns FunctionCall
	 *     Minus returns FunctionCall
	 *     Minus.Minus_1_0 returns FunctionCall
	 *     Multiply returns FunctionCall
	 *     Multiply.Multiply_1_0 returns FunctionCall
	 *     Divide returns FunctionCall
	 *     Divide.Divide_1_0 returns FunctionCall
	 *     Comparison returns FunctionCall
	 *     Comparison.LessThan_1_0_0_1 returns FunctionCall
	 *     Comparison.Equal_1_0_1_1 returns FunctionCall
	 *     Comparison.GreaterThan_1_0_2_1 returns FunctionCall
	 *     FunctionCall returns FunctionCall
	 *     PrimaryExpression returns FunctionCall
	 *
	 * Constraint:
	 *     (name=ID (parameters+=Expression parameters+=Expression*)?)
	 */
	protected void sequence_FunctionCall(ISerializationContext context, FunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EventHandler returns GameStart
	 *     GameStart returns GameStart
	 *
	 * Constraint:
	 *     statements+=Statement*
	 */
	protected void sequence_GameStart(ISerializationContext context, GameStart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Game returns Game
	 *
	 * Constraint:
	 *     (variableDeclarations+=Variable* actorDefs+=Actor*)
	 */
	protected void sequence_Game(ISerializationContext context, Game semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns If
	 *     If returns If
	 *
	 * Constraint:
	 *     (predicate=Expression ifBlock+=Statement*)
	 */
	protected void sequence_If(ISerializationContext context, If semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EventHandler returns KeyPressed
	 *     KeyPressed returns KeyPressed
	 *
	 * Constraint:
	 *     (key=UPPERCASE statements+=Statement*)
	 */
	protected void sequence_KeyPressed(ISerializationContext context, KeyPressed semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns Minus
	 *     Expression returns Minus
	 *     Or returns Minus
	 *     Or.Or_1_0 returns Minus
	 *     And returns Minus
	 *     And.And_1_0 returns Minus
	 *     Plus returns Minus
	 *     Plus.Plus_1_0 returns Minus
	 *     Minus returns Minus
	 *     Minus.Minus_1_0 returns Minus
	 *     Multiply returns Minus
	 *     Multiply.Multiply_1_0 returns Minus
	 *     Divide returns Minus
	 *     Divide.Divide_1_0 returns Minus
	 *     Comparison returns Minus
	 *     Comparison.LessThan_1_0_0_1 returns Minus
	 *     Comparison.Equal_1_0_1_1 returns Minus
	 *     Comparison.GreaterThan_1_0_2_1 returns Minus
	 *     PrimaryExpression returns Minus
	 *
	 * Constraint:
	 *     (left=Minus_Minus_1_0 right=Multiply)
	 */
	protected void sequence_Minus(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMinusAccess().getMinusLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMinusAccess().getRightMultiplyParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns Multiply
	 *     Expression returns Multiply
	 *     Or returns Multiply
	 *     Or.Or_1_0 returns Multiply
	 *     And returns Multiply
	 *     And.And_1_0 returns Multiply
	 *     Plus returns Multiply
	 *     Plus.Plus_1_0 returns Multiply
	 *     Minus returns Multiply
	 *     Minus.Minus_1_0 returns Multiply
	 *     Multiply returns Multiply
	 *     Multiply.Multiply_1_0 returns Multiply
	 *     Divide returns Multiply
	 *     Divide.Divide_1_0 returns Multiply
	 *     Comparison returns Multiply
	 *     Comparison.LessThan_1_0_0_1 returns Multiply
	 *     Comparison.Equal_1_0_1_1 returns Multiply
	 *     Comparison.GreaterThan_1_0_2_1 returns Multiply
	 *     PrimaryExpression returns Multiply
	 *
	 * Constraint:
	 *     (left=Multiply_Multiply_1_0 right=Divide)
	 */
	protected void sequence_Multiply(ISerializationContext context, Multiply semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplyAccess().getMultiplyLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplyAccess().getRightDivideParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns Or
	 *     Expression returns Or
	 *     Or returns Or
	 *     Or.Or_1_0 returns Or
	 *     And returns Or
	 *     And.And_1_0 returns Or
	 *     Plus returns Or
	 *     Plus.Plus_1_0 returns Or
	 *     Minus returns Or
	 *     Minus.Minus_1_0 returns Or
	 *     Multiply returns Or
	 *     Multiply.Multiply_1_0 returns Or
	 *     Divide returns Or
	 *     Divide.Divide_1_0 returns Or
	 *     Comparison returns Or
	 *     Comparison.LessThan_1_0_0_1 returns Or
	 *     Comparison.Equal_1_0_1_1 returns Or
	 *     Comparison.GreaterThan_1_0_2_1 returns Or
	 *     PrimaryExpression returns Or
	 *
	 * Constraint:
	 *     (left=Or_Or_1_0 right=And)
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrAccess().getOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrAccess().getRightAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns Plus
	 *     Expression returns Plus
	 *     Or returns Plus
	 *     Or.Or_1_0 returns Plus
	 *     And returns Plus
	 *     And.And_1_0 returns Plus
	 *     Plus returns Plus
	 *     Plus.Plus_1_0 returns Plus
	 *     Minus returns Plus
	 *     Minus.Minus_1_0 returns Plus
	 *     Multiply returns Plus
	 *     Multiply.Multiply_1_0 returns Plus
	 *     Divide returns Plus
	 *     Divide.Divide_1_0 returns Plus
	 *     Comparison returns Plus
	 *     Comparison.LessThan_1_0_0_1 returns Plus
	 *     Comparison.Equal_1_0_1_1 returns Plus
	 *     Comparison.GreaterThan_1_0_2_1 returns Plus
	 *     PrimaryExpression returns Plus
	 *
	 * Constraint:
	 *     (left=Plus_Plus_1_0 right=Minus)
	 */
	protected void sequence_Plus(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.BINARY_OPERATOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusAccess().getPlusLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusAccess().getRightMinusParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns Not
	 *     Expression returns Not
	 *     Or returns Not
	 *     Or.Or_1_0 returns Not
	 *     And returns Not
	 *     And.And_1_0 returns Not
	 *     Plus returns Not
	 *     Plus.Plus_1_0 returns Not
	 *     Minus returns Not
	 *     Minus.Minus_1_0 returns Not
	 *     Multiply returns Not
	 *     Multiply.Multiply_1_0 returns Not
	 *     Divide returns Not
	 *     Divide.Divide_1_0 returns Not
	 *     Comparison returns Not
	 *     Comparison.LessThan_1_0_0_1 returns Not
	 *     Comparison.Equal_1_0_1_1 returns Not
	 *     Comparison.GreaterThan_1_0_2_1 returns Not
	 *     PrimaryExpression returns Not
	 *
	 * Constraint:
	 *     expression=PrimaryExpression
	 */
	protected void sequence_PrimaryExpression(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.UNARY_OPERATOR__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.UNARY_OPERATOR__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryExpressionAccess().getExpressionPrimaryExpressionParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Sleep
	 *     Sleep returns Sleep
	 *
	 * Constraint:
	 *     duration=DECIMAL
	 */
	protected void sequence_Sleep(ISerializationContext context, Sleep semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.SLEEP__DURATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.SLEEP__DURATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSleepAccess().getDurationDECIMALTerminalRuleCall_3_0(), semanticObject.getDuration());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EventHandler returns SpriteClicked
	 *     SpriteClicked returns SpriteClicked
	 *
	 * Constraint:
	 *     statements+=Statement*
	 */
	protected void sequence_SpriteClicked(ISerializationContext context, SpriteClicked semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns VariableAssignment
	 *     AbstractElement returns VariableAssignment
	 *     VariableAssignment returns VariableAssignment
	 *
	 * Constraint:
	 *     (variableName=ID expression=Expression)
	 */
	protected void sequence_VariableAssignment(ISerializationContext context, VariableAssignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.VARIABLE_ASSIGNMENT__VARIABLE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.VARIABLE_ASSIGNMENT__VARIABLE_NAME));
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.VARIABLE_ASSIGNMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.VARIABLE_ASSIGNMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAssignmentAccess().getVariableNameIDTerminalRuleCall_0_0(), semanticObject.getVariableName());
		feeder.accept(grammarAccess.getVariableAssignmentAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     (name=ID expression=Expression)
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.VARIABLE__NAME));
			if (transientValues.isValueTransient(semanticObject, KlangPackage.Literals.VARIABLE__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KlangPackage.Literals.VARIABLE__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVariableAccess().getExpressionExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns WhileLoop
	 *     WhileLoop returns WhileLoop
	 *
	 * Constraint:
	 *     (predicate=Expression loopBlock+=Statement*)
	 */
	protected void sequence_WhileLoop(ISerializationContext context, WhileLoop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
