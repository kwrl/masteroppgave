grammar com.kaurel.klang.xtext.Klang with org.eclipse.xtext.common.Terminals

import "http://www.example.org/klang"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Game:
	{Game}
	(variableDeclarations+=Variable)*
	(actorDefs+=Actor)*;

Actor returns Actor:
	{Actor}
	entity=Entity
	BEGIN
	(variableDeclarations+=Variable)*
	(eventHandlers+=EventHandler)*
	END;

Entity:
	'sprite' {SpriteEntity} name=ID | 'scene' {SceneEntity};

EventHandler:
	GameStart | SpriteClicked | KeyPressed | CollidesWith
;	
	
Statement returns Statement:
	WhileLoop | If | VariableAssignment	| ForeverLoop | FunctionCall | Sleep
;


GameStart returns EventHandler:
	{GameStart}
	'when' 'game' 'starts'
	BEGIN
	(statements+=Statement)*
	END
;

SpriteClicked returns EventHandler:
	{SpriteClicked}
	'when' 'clicked'
	BEGIN
	(statements+=Statement)*
	END
;

KeyPressed returns EventHandler:
	{KeyPressed}	
	'when' key=UPPERCASE 'key' 'pressed'
	BEGIN
	(statements+=Statement)*
	END

;

CollidesWith returns EventHandler: 
	{CollidesWith}
	'when' 'collides' 'with' target=[SpriteEntity]
	BEGIN
	(statements+=Statement)*
	END

;


WhileLoop returns Statement:
	{WhileLoop}
	'while' predicate=Expression
	BEGIN
	(loopBlock+=Statement)*
	END;

If returns Statement:
	{If}
	'if' predicate=Expression
	BEGIN
	(ifBlock+=Statement)*
	END;

ForeverLoop returns Statement:
	{ForeverLoop}
	'forever'
	BEGIN
	(loopStatements+=Statement)*
	END;

Variable:
	'var' name=ID '=' expression=Expression;
	
AbstractElement:
	VariableAssignment | Expression 
;

VariableAssignment:
	variableName=ID '='	expression=Expression
;

Sleep returns Statement:
	{Sleep}
	'sleep' '(' duration=DECIMAL ')'
;


Expression:
	Or;

Or returns Expression:
	And ({Or.left=current} 'or' right=And)*;

And returns Expression:
	Comparison ({And.left=current} 'and' right=Comparison)*;

Plus returns Expression:
	Minus ({Plus.left=current} '+' right=Minus)*;

Minus returns Expression:
	Multiply ({Minus.left=current} '-' right=Multiply)*;

Multiply returns Expression:
	Divide ({Multiply.left=current} '*' right=Divide)*;

Divide returns Expression:
	PrimaryExpression ({Divide.left=current} '/' right=PrimaryExpression)*;

Comparison returns Expression:
	Plus (('<' {LessThan.left=current} | '==' {Equal.left=current} | '>' {GreaterThan.left=current}) right=Plus)*;

FunctionCall returns FunctionCall:
	name=ID '(' (parameters+=Expression(',' parameters+=Expression)*)? ')';

PrimaryExpression returns Expression:
	'(' Expression ')' |
	{Not} 'not' expression=PrimaryExpression |
	FunctionCall |
	AtomicExpression;

AtomicExpression returns Expression:
	{BooleanLiteral} (value?='true' | 'false') |
	{DoubleLiteral} value=DECIMAL |
	{StringLiteral} value=STRING |
	{VariableRef} variableName=ID;

terminal BEGIN:
	'synthetic:BEGIN';

terminal END:
	'synthetic:END';

terminal UPPERCASE:
	('A'..'Z' | '0'..'9')*
;	

terminal DECIMAL returns ecore::EDouble:
	INT ('.' INT)?;
